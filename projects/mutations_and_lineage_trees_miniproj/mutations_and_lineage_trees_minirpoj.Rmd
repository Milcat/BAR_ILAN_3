---
title: "Mutations and Lineage trees - miniproj"
author: "Milca Tarshish"
date: "9/1/2019"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Loading libraries:
```{r, message=F}
library(alakazam)
library(igraph)
library(shazam)
library(crayon)
library(dplyr)
```

## Processing data: 

### Adding GERMLINE_IMGT_D_MASK, GERMLINE_IMGT and CLONE columns to database
In case the change-o database does not have columns "GERMLINE_IMGT_D_MASK", "GERMLINE_IMGT" and "CLONE", then this can be calculated by running following python script:  

C:\\Bar_Ilan_3\\projects\\mutations_and_lineage_trees_miniproj\\createGermlines_and_DefineClones.py

Note that that in case the original databse includes colunmes named N1_LENGTH and N2_LENGTH (instead of NP1_LENGTH and NP2_LENGTH) - then they must be renamed to NP1_LENGTH and NP2_LENGTH accordingly.


### Functions for cleaning some lines from database and getting relevant clones list:  

#### Function make_clones_freq_df:
Reads db, and return a list of clone numbers and their fequency:  
```{r func_makes_clones_freq_df}
make_clones_freq_df<-function(data,clone_col="CLONE") {
  clones_freq<-as.data.frame(ftable(data[,c(clone_col)]))
  names(clones_freq)<-c("CLONE","CLONE_FREQ")
  return(clones_freq)
}
```

#### Function list_onread_clones:  
This function gets as input a clone frequence data frame, and returns a list of clone numbers that have a frequencey of 1.  
```{r func_list_oneread_clones}
list_oneread_clones<-function(df,clone_col="CLONE",freq_col="CLONE_FREQ") {
  #oneread_clones_df<-setNames(data.frame(matrix(ncol=2,nrow=100)), c("CLONE","CLONE_FREQ"))
  fc<-df[[freq_col]]
  cc<-df[[clone_col]]
  len<-length(fc)
  oneread_clones_df<-data.frame("CLONE"=cc,"CLONE_FREQ"=fc)
  oneread_clones_df<-subset(oneread_clones_df,CLONE_FREQ==1)
  oneread_clones<-oneread_clones_df$CLONE
  return(oneread_clones)
}
```


#### Function make_list_one_read_clones: 
Reads db, and return a list of clone numbers that are of one size (=one read in those clones):  
```{r func_make_list_one_read_clones} 
#make_list_one_read_clones<-function(db,clone_col="CLONE") {
#  clones_factor<-db[,c(clone_col)]
#  clones_factor_table<-table(clones_factor)
#  clones_factor_df<-as.data.frame(clones_factor_table)
#  clones_factor_df_oneread<-subset(clones_factor_df,Freq==1)
#  one_read_clones<-as.integer(clones_factor_df_oneread[,c("clones_factor")])
#  setClass("oneread_class", slots=list(clones_list="integer", clones_freq="data.frame"))
#  ret_class<-new("oneread_class",clones_list=one_read_clones,clones_freq=clones_factor_df)
#  return(ret_class)
#}
```

#### Function make_db_oneread_clone:  
This function gets as input a db, and returns as output a subset db - of lines which belong  
to clones with one read.  
```{r func_make_db_oneread_clone}
make_db_oneread_clone<-function(db,clone_col="CLONE") {
  clones_freq<-make_clones_freq_df(data=db,clone_col=clone_col)
  oneread_clones_list<-list_oneread_clones(clones_freq)
  # a trick for passing through the function the clone_col name:
  db$CLONE1<-db[[clone_col]]
  oneread_clones_db<-subset(db,subset = (CLONE1 %in% oneread_clones_list))
  oneread_clones_db<-select(oneread_clones_db,-c(CLONE1))
  return(oneread_clones_db)
}
```

#### Function db_remove_oneread_clones:  
This function gets as input a db, and returns as output a line subset db - of lines which belong  
to clones of 2 or more reads.  
```{r func_db_remove_oneread_clones}
db_remove_oneread_clones<-function(db,clone_col="CLONE") {
  clones_freq<-make_clones_freq_df(data=db,clone_col=clone_col)
  clones_list<-list_oneread_clones(clones_freq)
  multireads_clones_db<-filter(db,!(!!as.name(clone_col) %in% clones_list))
  return(multireads_clones_db)
}
```

#### Function make_germ_db:  
This function gets as input a db, and returns as output same dimention db, but of germline sequences of original db.  
```{r func_make_germ_db}
#make_germ_db<-function(db,ger_col="GERMLINE_IMGT",seq_col="SEQUENCE_IMGT",seq_id_col="SEQUENCE_ID",
#                            clone_col="CLONE",cols2empty=NA) {
#  db_germ<-db
#  db_germ[,c(seq_col)]<-db[,c(ger_col)]
#  db_germ[,c(seq_id_col)]<-paste("Germline_",db[,c(clone_col)],sep="")

#  if (!is.na(cols2empty[1])) {
#      db_germ[,c(cols2empty)]<-""
#  }
#  return(db_germ)
#}
```

#### Function enlarge_db_with_germ:  
This function gets as input a db, and returns an elarged db (with more rows):  
A new row is added for each read in original db whic belongs to a clone of size 1.  
The new row added - is the germline infor for this read.  
Doing this - since otherwise - lineage trees will not be built for such clones.   
```{r func_enlarge_db_with_germ}
#enlarge_db_with_germ<-function(db,ger_col="GERMLINE_IMGT",seq_col="SEQUENCE_IMGT",seq_id_col="SEQUENCE_ID",
#                            clone_col="CLONE",cols2empty=NA) {
#  oneread_clone_db<-make_db_oneread_clone(db=db,clone_col=clone_col) 
#  germ_db<-make_germ_db(db=oneread_clone_db,ger_col=ger_col,seq_col=seq_col,seq_id_col=seq_id_col,
#                            clone_col=clone_col,cols2empty=NA) 
#  enlarged_db<-rbind(db,germ_db)
#}
```

#### Function proper_clone:
Checks if a specific clone in database - has more than one GERMLINE_IMGT_D_MASK value:
It will return TRUE if the clone is a proper clone (meaning all its lines in database have same GERMLINE_IMGT_VALUE),
and FALSE otherwise.
```{r func_proper_clone}
#proper_clone <- function(db,clone_num,GERMLINE_IMGT_col="GERMLINE_IMGT") {
#        clone_db<-filter(db,CLONE==clone_num)
#        # since the field GERMLINE_IMGT_D_MASK is of factor type of very large size
#        #- need first to change it to character type, and then back to factor, which now will be of much lower size:
#        germ_igmt_d_mask_factor_table<-table(as.factor(as.character(clone_db[,GERMLINE_IMGT_col])))
#        if(length(germ_igmt_d_mask_factor_table)==1) {
#                return(T)
#        }
#        else {
#                return(F)
#        }
#}
```


#### Function cleanup_clones:
filtering out lines of database that have improper clones, which either:  
 - clones of size 1.  
 - belong to clones with 2 (or more) different values for GERMLINE_IMGT_D_MASK:  
```{r func_cleanup_clones}
#cleanup_clones<-function(db,clone_col="CLONE",GERMLINE_IMGT_col="GERMLINE_IMGT") {
#  clones_list<-unique(db[,c(clone_col)])
#  for (i in clones_list) {
#          if (proper_clone(db=db,clone_num = i,GERMLINE_IMGT_col = GERMLINE_IMGT_col)==F) {
#                  db<-filter(db,!!as.name(clone_col)!=i)
#                  print(i)
#          }
#  }
#  return(db)
#}
```

#### Function make_clones_list:  
This function gets a db as input and generates a list of clones to run on  
The list will include each clone number only once.  
```{r func_make_clones_list}
make_clones_list<- function(db, clone_col="CLONE") {
  clones_list<-unique(db[,c(clone_col)])
  return(clones_list)
}
```

#### Function make_clones_table:  
This function gets a db as input and generates a table of clone number and their frequencey in the db.  
```{r func_make_clones_table}
make_clones_table<- function(db, clone_col="CLONE") {
  clones_factor<-as.factor(db[,c(clone_col)])
  clones_table<-table(clones_factor)
  return(clones_table)
}
```

### Functions that will run in a loop later on all clones in db to build a new db with lineage tree info:
#### Function make_chaneoClone_cur_clone:  
Creating a changeoclone object for one specific clone:  
```{r func_make_chaneoClone_cur_clone}
make_chaneoClone_cur_clone <- function(db,cur_clone_num,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT_D_MASK",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  cur_clone_db<-subset(db,CLONE==cur_clone_num)
  cur_clone_obj<-makeChangeoClone(data=cur_clone_db,id=id,seq=seq,germ=germ,vcall=vcall,jcall=jcall,
                                       junc_len=junc_len,clone=clone,mask_char=mask_char,
                                       max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj@data$V_CALL<-cur_clone_obj@v_gene
  cur_clone_obj@data$J_CALL<-cur_clone_obj@j_gene
  cur_clone_obj@data$CLONE<-cur_clone_obj@clone
  cur_clone_obj@data$GERMLINE_IMGT_D_MASK<-cur_clone_obj@germline
  cur_clone_obj@data$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  # marking whether the cur_clone_obj data is of at least 2 lines:
  # If only one line, it means that even though the original clone size was of more than 1 line 
  # - then all the lines were the same, and they all collapsed to one line while building a clone object.
  # So in this case - no point of building a lineage tree with one line in a clone.
  cur_clone_size<-dim(cur_clone_obj@data)[1]
  setClass("make_chaneoClone_cur_clone_class", slots=list(ChangeoClone_obj="ChangeoClone", size="numeric"))
  ret_class<-new("make_chaneoClone_cur_clone_class",ChangeoClone_obj=cur_clone_obj,size=cur_clone_size)
  return(ret_class)
}
```

#### function make_graph_cur_clone: 
Making a graph out of ChangeoClone object:  
```{r func_make_graph_cur_clone}
make_graph_cur_clone<-function(cur_clone_obj,dnapars_exec) {
  # The below line is in order to avoid warning message
  # (message: "binding factor and character vector, coercing into character vector")
  cur_clone_obj@data$SEQUENCE_ID<-as.character(cur_clone_obj@data$SEQUENCE_ID) 
  cur_clone_graph<-buildPhylipLineage(cur_clone_obj,dnapars_exec,rm_temp = TRUE)  
  # in case that the cur_clone_num does not include at least 2 unique sequences - the cur_clone_graph will be "NULL".
  #note: "N" instead of A/C/G/T does not make a sequence unique.
  return(cur_clone_graph)
}
```

#### function make_graph_df:  
Generating a data frame from graph object, and mering it with clone database (only for objects with more than one line):  
```{r func_make_graph_df}
make_graph_df <- function(cur_clone_graph,cur_clone_obj) {
  # extracting the cur_clone_num from the inputs to function:
  cur_clone_num<-cur_clone_obj@clone
  # generating a data frame from the clone igraph object (- for getting the inferred sequences from the graph,
  # and the parent information):
  cur_clone_graph_df<-summarizeSubtrees(cur_clone_graph,fields="sequence")
  # merging the db from clone object and from graph:
  cur_clone_merged_df<-merge(x=cur_clone_obj@data,y=cur_clone_graph_df,by.x="SEQUENCE_ID",by.y="NAME",all=T)
  # Renaming SEQUENCE_ID column to ORIG_SEQUENCE_ID, and renaming PARENT to ORIG_PARENT:
  cur_clone_merged_df$ORIG_SEQUENCE_ID<-cur_clone_merged_df$SEQUENCE_ID
  cur_clone_merged_df$ORIG_PARENT<-cur_clone_merged_df$PARENT
 
  # uniquifying some values in merged data frame, and filling some missing values:
  
  #1. Replacing inferred sequences names with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices
  cur_clone_merged_df$PARENT<-gsub(pattern="Inferred",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Inferred",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Inferred",x=V(cur_clone_graph)$label,
                                 replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  
  #2. Replacing Germline sequence name with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices:
  cur_clone_merged_df$PARENT<-gsub(pattern="Germline",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Germline_",cur_clone_num,sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Germline",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Germline_",cur_clone_num,sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Germline",x=V(cur_clone_graph)$label,
                                 replacement= paste("Germline_",cur_clone_num,sep=""))
  
  #3. Now need to fill in missing values for germline sequence and inffered sequences:
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$J_CALL<-cur_clone_obj@j_gene
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  cur_clone_merged_df$GERMLINE_IMGT_D_MASK<-cur_clone_obj@germline
  
  #4. setting a new SEQUENCE_ID column with following format:  
  #<CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.   
  cur_clone_merged_df$SEQUENCE_ID <-  
                              paste(cur_clone_num,"_",c(1:length(cur_clone_merged_df$ORIG_SEQUENCE_ID)),sep="")
  cur_clone_merged_df<-mutate(cur_clone_merged_df,
                              SEQUENCE_ID=ifelse(grepl("Germline|Inferred",ORIG_SEQUENCE_ID),
                                                 paste(cur_clone_num,"_",ORIG_SEQUENCE_ID,sep=""),SEQUENCE_ID))

  #5. Doing the same for PARENT column: 
  # setting a new PARENT column with following format:  
  # <CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.
  cur_clone_merged_df$PARENT<-cur_clone_merged_df[match(cur_clone_merged_df$ORIG_PARENT,                                                                    cur_clone_merged_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]
 
  #6. Removing the SEQUENCE column, as it does not include sequences of germline and inferred.
  #Renaming the "sequence" column to "SEQUENCE"
  cur_clone_merged_df<-subset(cur_clone_merged_df,select=c(-SEQUENCE))
  cur_clone_merged_df<-rename(cur_clone_merged_df,SEQUENCE=sequence)

  #7. Adding the parent sequence as a new column:
  cur_clone_merged_df$PARENT_SEQUENCE<-cur_clone_merged_df[match(cur_clone_merged_df$PARENT,
                                                                 cur_clone_merged_df$SEQUENCE_ID),"SEQUENCE"]         
  # filling the parent sequece of the Germline sequence to be its own sequence (=GERMLINE_IMGT_D_MASK):
  cur_clone_merged_df<-mutate(cur_clone_merged_df,PARENT_SEQUENCE=ifelse(is.na(PARENT_SEQUENCE),
                                                                         GERMLINE_IMGT_D_MASK,PARENT_SEQUENCE))
  return(cur_clone_merged_df)
}
```

#### function draw_clone_lineage_tree:  
For viewing a tree plot of a specific clone:  
```{r func_draw_clone_lineage_tree, fig.width = 15, fig.height=10}
draw_clone_lineage_tree<-function(db,cur_clone=NULL,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT_D_MASK",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
  ret_class<-make_chaneoClone_cur_clone(db=db,cur_clone_num=cur_clone,id=id,seq=seq,germ=germ,                                                         vcall=vcall,jcall=jcall,junc_len=junc_len, 
                                        clone=clone,mask_char=mask_char,
                                        max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  V(cur_clone_graph)$color <- ifelse(grepl("Germline",V(cur_clone_graph)$label),"lightgreen",
                              ifelse(grepl("Inferred",V(cur_clone_graph)$label),"lightpink","lightblue"))
  #making the graph vertices show the simple SEQUENCE_ID
  cur_clone_only_df<-filter(all_clones_merged_df,CLONE==cur_clone)
  #V(cur_clone_graph)$seq_num<-cur_clone_only_df[match(V(cur_clone_graph)$label,
  #                                                    cur_clone_only_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]   
  E(cur_clone_graph)$label <- ""
  par(mar=c(0, 0, 0, 0) + 1)
  plot(cur_clone_graph, layout=layout_as_tree, edge.arrow.mode=0, 
       vertex.frame.color="black", vertex.label.cex=0.8,
       vertex.label.color="black", vertex.size=18, vertex.label=V(cur_clone_graph)$seq_num, 
       main=paste("Lineage tree for clone ",cur_clone))
  legend("topleft", c("Germline", "Inferred", "Sample"), 
       fill=c("lightgreen", "lightpink", "lightblue"), cex=0.75)
}
```

#### function make_region:  
Getting as input a JuNCTION_LENGTH, SEQUENCE_IMGT,  
and outputing a RegionDefinition object that includes following regions:   
FWR1: Bases	1 to 78     (based on IMGT_V_BY_REGIONS definitions)  
CDR1: Bases	79 to 114   (based on IMGT_V_BY_REGIONS definitions) 
FWR2: Bases	115 to 165  (based on IMGT_V_BY_REGIONS definitions)  
CDR2: Bases	166 to 195  (based on IMGT_V_BY_REGIONS definitions)  
FWR3: Bases	196 to 312  (based on IMGT_V_BY_REGIONS definitions)
CDR3: Bases	313 to (313+JUNCTION_LENGTH-6) - since junction sequnece includes (on the left) the last codon from FWR3,  
and (on the right) the first codon from FWR4.  
FWR4: Bases	(313+JUNCTION_LENGTH-6+1) to SEQUENCE_LENGTH.  

```{r func_make_region}
make_region <- function(JUNCTION_LENGTH,SEQUENCE_IMGT) {
  # First need to extract sequence length from sequence:
  SEQ_LEN<-nchar(SEQUENCE_IMGT)
  name<-"IMGT_FULL_BY_REGIONS"
  description<-"IMGT numbering scheme defining the V(D)J segment by individual CDR and FWR regions, including CDR3 and FWR4"
  boundaries<-factor(IMGT_V_BY_REGIONS@boundaries  ,levels=c(levels(IMGT_V_BY_REGIONS@boundaries),"CDR3","FWR4"))
  boundaries[313:(313+as.integer(JUNCTION_LENGTH)-6-1)]<-factor("CDR3")
  boundaries[(313+as.integer(JUNCTION_LENGTH)-6):SEQ_LEN]<-factor("FWR4")
  seqLength<-SEQ_LEN
  regions<-c("CDR1","CDR2","CDR3","FWR1","FWR2","FWR3","FWR4")
  labels<-c("CDR1_R","CDR1_S","CDR2_R","CDR2_S","CDR3_R","CDR3_S","FWR1_R","FWR1_S","FWR2_R","FWR2_S","FWR3_R","FWR3_S","FWR4_R","FWR4_S")
  citation<-"http://www.imgt.org/IMGTScientificChart/Nomenclature/IMGT-FRCDRdefinition.html"
  ret_class<-new("RegionDefinition",name=name,description=description,boundaries=boundaries,
                                    seqLength=seqLength,regions=regions,labels=labels,
                                    citation=citation)
  return(ret_class)
}
```

#### function get_clone_region:  
This function gets as input a clone number and a data frame with sequences and their clone number,  
And returns the RegionDefinition object of type IMGT_FULL_BY_REGIONS for this specific clone.  
The function gets as input also the column name of the clone and sequence in the data frame.
Note that the region definition is same for all sequences in clone - so doing it based on first sequence in clone.  
```{r func_get_clone_region}
get_clone_region <- function(db,clone_num,seq_col="SEQUENCE",junc_len_col="JUNCTION_LENGTH",clone_col="CLONE") {
  # getting one of the sequences of the specific clone: 
  # clone_col1<-as.symbol(clone_col)
  clone_db<-filter(db,(!!as.name(clone_col))==clone_num)
  #clone_db<-filter(db,CLONE==clone_num)
  seq<-clone_db[1,seq_col]
  junc_len<-clone_db[1,junc_len_col]
  reg<-make_region(JUNCTION_LENGTH = junc_len, SEQUENCE_IMGT = seq)
  return(reg)
}
```

#### function observedMutations_L:  
Very similar to observedMutations function, except that it runs with regard to parent sequence in lineage tree,  
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_observedMutations_L}
observedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", germlineColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE", mutationDefinition = NULL, 
                                ambiguousMode = c("eitherOr", "and"), 
                                frequency = FALSE, combine = FALSE, nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function observedMutations with its own regionDefinition.
  # For all clones - the germlineColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"])
    clone_observeedMutations_db<-observedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn=germlineColumn,
                                                   regionDefinition=cur_clone_reg,                                                                                mutationDefinition=mutationDefinition,
                                                   ambiguousMode=ambiguousMode,
                                                   frequency=frequency,combine=combine,nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      observeedMutations_db<-clone_observeedMutations_db
      first_clone<-0
    }
    else {
      observeedMutations_db<-rbind(observeedMutations_db,clone_observeedMutations_db)
    }
  } # end of for loop
  return(observeedMutations_db)
} # end of function
```

#### function expectedMutations_L:  
Very similar to expectedMutations function, except that it runs with regard to parent sequence in lineage tree,
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_expectedMutations_L}
expectedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", germlineColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE",targetingModel = HH_S5F, mutationDefinition = NULL, 
                                nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function expectedMutations with its own regionDefinition.
  # For all clones - the germlineColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"])
    clone_expectedMutations_db<-expectedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn =germlineColumn,
                                                   targetingModel=targetingModel,
                                                   regionDefinition=cur_clone_reg,
                                                   mutationDefinition=mutationDefinition,
                                                   nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      expectedMutations_db<-clone_expectedMutations_db
      first_clone<-0
    }
    else {
      expectedMutations_db<-rbind(expectedMutations_db,clone_expectedMutations_db)
    }
  } # end of for loop
  return(expectedMutations_db)
} # end of function
```

### Using all functions above on database:  
```{r use_func_on_db}
# 1. Loading data from HCV_B database:  
file_pointer<-"C:\\Bar Ilan 3 data - not backed up\\HCV_B\\CI10_rename_p1_p2_germ-pass_clone-pass_germ-pass.tab"
clones_db<-read.csv(file_pointer, header=TRUE,sep='\t')
dim(clones_db)

# 2. Removing from db sequences that their IMGT sequence is shorter than 312 nucleoties.
#    The reason for this is that running Expected mutations on them does not run properly, as they are missing full
#    range of FWR1/CDR1/FWR2/CDR2/FWR3 which is 312 nucleotides (not sure at all why they even exist in the db). 
clones_db<-subset(clones_db,nchar(as.character(SEQUENCE_IMGT))>=312)

# 3. Keeping in a list - the clone number which have only one read on them:
clones_freq<-make_clones_freq_df(data=clones_db,clone_col="CLONE")
oneread_clones<-list_oneread_clones(clones_freq) 


# 4. Making a db for only clones of size 1:
oneread_clones_db<-make_db_oneread_clone(clones_db,clone_col="CLONE")

# 5. Removing clones of size 1. They will be handeled later, and added back to db.
#   We could add them back in 2 options in pipeline: 
#     - option 1: before running makeChangeoClone.
#     - option 2: at the end of the pipeline.
#   In any case - trying to generate an igraph of a clone of 1 read - will fail. So need to add to the one read clone - 
#   it's germline. Adding it like in option 1 - might be problematic in cases where the read is equal to it's germline. 
#   In this case - the makeChangeoClone will collapse the read with its germline sequence, thus generating an igrpah object
#   from the clone - will not work. This is why it will be done by option 2.
clones_db<-db_remove_oneread_clones(clones_db,clone_col="CLONE")

# 6. create a list of clones to loop on:  
clones_to_build_trees<-make_clones_list(clones_db)
#clones_to_build_trees<-c(4070,12,259,11)

# 7. Loop on all clones in db above:
first_clone<-TRUE
#loop_start_time<-Sys.time()
dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
for (clone_index in clones_to_build_trees) {
  ret_class<-make_chaneoClone_cur_clone(db = clones_db,cur_clone_num = clone_index)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_size<-ret_class@size
  # in case  the clone size is of 1 row - skip to next clone, as no lineage tree is relevant here:
  # This also suppresses following warning:
  # "Warning in buildPhylipLineage(cur_clone_obj, dnapars_exec, rm_temp = TRUE): 
  # Clone 7781 was skipped as it does not   contain at least 2 unique sequences"
  if(cur_clone_size==1) {
    next
  }
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  if (!is.null(cur_clone_graph)) { 
    cur_clone_merged_df<-make_graph_df(cur_clone_graph,cur_clone_obj)
    if(first_clone) {
      first_clone<-FALSE
      all_clones_merged_df<-cur_clone_merged_df
    } #endif first_clone
    else {
      all_clones_merged_df<-rbind(all_clones_merged_df,cur_clone_merged_df)
    }
  } # endif
} # endfor




# 8. preparing a db with columns same as final db (all_clones_merged_df) - that includes the clones with one read:  
#    Tis will be added later to final db.
oneread_clones_db_new<-setNames(data.frame(matrix(ncol = length(names(all_clones_merged_df)), nrow = length(oneread_clones))), 
                                names(all_clones_merged_df))
oneread_clones_db_new[,"CLONE"]                  <-oneread_clones_db[,"CLONE"]
oneread_clones_db_new[,"V_CALL"]                 <-oneread_clones_db[,"V_CALL"]
oneread_clones_db_new[,"J_CALL"]                 <-oneread_clones_db[,"J_CALL"]
oneread_clones_db_new[,"GERMLINE_IMGT_D_MASK"]   <-oneread_clones_db[,"GERMLINE_IMGT_D_MASK"]
oneread_clones_db_new[,"JUNCTION_LENGTH"]        <-oneread_clones_db[,"JUNCTION_LENGTH"]
oneread_clones_db_new[,"SEQUENCE"]               <-oneread_clones_db[,"SEQUENCE_IMGT"]
oneread_clones_db_new[,"ORIG_SEQUENCE_ID"]       <-oneread_clones_db[,"SEQUENCE_ID"]
oneread_clones_db_new[,"PARENT_SEQUENCE"]        <-oneread_clones_db[,"GERMLINE_IMGT"]
oneread_clones_db_new[,"PARENT"]                 <-paste(oneread_clones_db[,"CLONE"],"_Germline",sep="")
oneread_clones_db_new[,"SEQUENCE_ID"]            <-paste(oneread_clones_db[,"CLONE"],"_1",sep="")
# the bellow is replacing in column "GERMLINE_IMGT_D_MASK" the string "." with "N". 
# This is since in clones_db this columns uses ".", while in all_clones_merged_df - this column uses "N":
oneread_clones_db_new<-mutate(oneread_clones_db_new,GERMLINE_IMGT_D_MASK=gsub(pattern="\\.",replacement = "N",
                                                                               oneread_clones_db_new$GERMLINE_IMGT_D_MASK))
oneread_clones_db_new<-mutate(oneread_clones_db_new,PARENT_SEQUENCE=gsub(pattern="\\.",replacement = "N",
                                                                               oneread_clones_db_new$PARENT_SEQUENCE))
oneread_clones_db_new<-mutate(oneread_clones_db_new,SEQUENCE=gsub(pattern="\\.",replacement = "N",
                                                                               oneread_clones_db_new$SEQUENCE))

# 9. adding for each one read clone - a new line of its germline:
oneread_clones_db_germ<-oneread_clones_db_new
oneread_clones_db_germ$SEQUENCE_ID<-oneread_clones_db_new$PARENT
oneread_clones_db_germ$SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT_D_MASK
oneread_clones_db_germ$PARENT<-"NA"
oneread_clones_db_germ$ORIG_PARENT<-"Germline"
oneread_clones_db_germ$PARENT_SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT_D_MASK
oneread_clones_db_new<-rbind(oneread_clones_db_new,oneread_clones_db_germ)
oneread_clones_db_new$SEQUENCE<-as.character(oneread_clones_db_new$SEQUENCE)
oneread_clones_db_new$V_CALL<-as.character(oneread_clones_db_new$V_CALL)
oneread_clones_db_new$J_CALL<-as.character(oneread_clones_db_new$J_CALL)
oneread_clones_db_new$CLONE<-as.character(oneread_clones_db_new$CLONE)

# 10. adding the one read clone db to the main db:
all_clones_merged_df<-rbind(all_clones_merged_df,oneread_clones_db_new)


#loop_end_time<-Sys.time()
#print(loop_start_time)
#print(loop_end_time)
all_clones_merged_df<-observedMutations_L(all_clones_merged_df,sequenceColumn = "SEQUENCE")
all_clones_merged_df<-expectedMutations_L(all_clones_merged_df,sequenceColumn = "SEQUENCE")
write.csv(all_clones_merged_df,file="C:\\Bar_Ilan_3\\projects\\all_clones_merged_df.csv")

```



