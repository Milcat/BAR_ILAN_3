---
title: "Mutations and Lineage trees - miniproj"
author: "Milca Tarshish"
date: "9/1/2019"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Loading libraries:
```{r, message=F}
library(alakazam)
library(igraph)
library(shazam)
library(crayon)
library(dplyr)
```

## Processing data: 

### Adding GERMLINE_IMGT_D_MASK column to database
In case the change-o database does not have a "GERMLINE_IMGT_D_MASK" column, then this can be calculated by running following python script:  

*import sys*  
*import os*  
*sys.path.append('C:\\Users\\milcat\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts')*  
*import CreateGermlines*   
*Germ_files_list=[\\  
                  "C:\\Bar Ilan 3 data - not backed up\\Change-O examples\\Changeo_Example\\IMGT_Human_IGHV.fasta",\\   
                  "C:\\Bar Ilan 3 data - not backed up\\Change-O examples\\Changeo_Example\\IMGT_Human_IGHD.fasta",\\    
                  "C:\\Bar Ilan 3 data - not backed up\\Change-O examples\\Changeo_Example\\IMGT_Human_IGHJ.fasta"]*      
*dbfile="C:\\Bar Ilan 3 data - not backed up\\HCV_B\\sC10_rename_p1_p2.tab"*    
*CreateGermlines.createGermlines(db_file=dbfile,references=Germ_files_list)*  
  
Note that that in case the original databse includes colunmes named N1_LENGTH and N2_LENGTH (instead of NP1_LENGTH and NP2_LENGTH) - then they must be renamed to NP1_LENGTH and NP2_LENGTH accordingly.
  
The above takes the file SC10_rename_p1_p2.tab w/o GERMLINE_IMGT_D_MASK column, and adds to it the GERMLINE_IMGT_D_MASK column.  
The output file is named SC10_rename_p1_p2_germ-pass.tab, which is the same content as SC10_rename_p1_p2.tab, but with an additional GERMLINE_IMGT_D_MASK column. 

### Defining clones:  
In case the Change-O database does not have a "CLONE" column - then this can be generated based on columns V_CALL, J_CALL and JUMCTION. 
Need to run the following python short script:


*import presto*  
*import changeo*  
*import sys*  
*import os*  
*sys.path.append('C:\\Users\\milcat\\AppData\\Local\\Programs\\Python\\Python36-32\\Scripts')*  
*import DefineClones*  
*os.chdir('C:\\Bar Ilan 3 data - not backed up\\Change-O examples\\Changeo_Example')*  
*os.getcwd()*  
*DefineClones.defineClones(db_file='C:\\Bar Ilan 3 data - not backed up\\HCV_B\\SC10_rename_p1_p2_germ-pass.tab')*  

The above takes the file SC10_rename_p1_p2_germ-pass.tab w/o CLONE column, and adds to it the CLONE column.  
The output file is named CI10_rename_p1_p2_germ-pass_clone-pass.tab, which is the same content as SC10_rename_p1_p2_germ-pass.tab, but with an additional CLONE column. 

### Loading data from HCV_B database:  
```{r}
file_pointer<-"C:\\Bar Ilan 3 data - not backed up\\HCV_B\\CI10_rename_p1_p2_germ-pass_clone-pass.tab"
clones_db<-read.csv(file_pointer, header=TRUE,sep='\t')
dim(clones_db)
clones_factor<-as.factor(clones_db$CLONE)
clones_factor_table<-table(clones_factor)
```
### cleaning some lines from database:
Removing lines which belong to clones of size 1 (meaning only one line for this clone):
```{r}
clones_db<-filter(clones_db,clones_factor_table[CLONE]!=1)
dim(clones_db)
```

Removing lines which belong to clones with 2 (or more) different values for GERMLINE_IMGT_D_MASK:
```{r}
#The bellow function checkes if a specific clone in a specific database - has more than one GERMLINE_IMGT_D_MASK value:
# It will return TRUE if the clone is a proper clone (meaning all its lines in database have same GERMLINE_IMGT_VALUE),
# and FALSE otherwise.
proper_clone <- function(db,clone_num) {
        clone_db<-filter(db,CLONE==clone_num)
        # since the field GERMLINE_IMGT_D_MASK is of factor type of very large size
        #- need first to change it to character type, and then back to factor, which now will be of much lower size:
        germ_igmt_d_mask_factor_table<-table(as.factor(as.character(clone_db$GERMLINE_IMGT_D_MASK)))
        if(length(germ_igmt_d_mask_factor_table)==1) {
                return(T)
        }
        else {
                return(F)
        }
}

# filtering out lines of database that have improper clones above:
clones_list<-unique(clones_db$CLONE)
for (i in clones_list) {
        if (proper_clone(clones_db,i)==F) {
                clones_db<-filter(clones_db,CLONE!=i)
        }
}
dim(clones_db)
#find 10 most largest clones:
clones_factor<-as.factor(clones_db$CLONE)
clones_factor_table<-table(clones_factor)
clones_to_build_trees<-as.numeric(names(clones_factor_table))
head(sort(clones_factor_table,decreasing = TRUE),n=20)
```
### defining some functions that will run in a loop later on all clones in clones_to_build_trees:
#### function make_chaneoClone_cur_clone: creating a changeoclone object for one specific clone:
```{r func_make_chaneoClone_cur_clone}
make_chaneoClone_cur_clone <- function(cur_clone_num,all_clones_db) {
  cur_clone_db<-subset(all_clones_db,CLONE==cur_clone_num)
  #print(cur_clone_db)
  cur_clone_obj<-makeChangeoClone(cur_clone_db)
  cur_clone_obj@data$V_CALL<-cur_clone_obj@v_gene
  cur_clone_obj@data$J_CALL<-cur_clone_obj@j_gene
  cur_clone_obj@data$CLONE<-cur_clone_obj@clone
  cur_clone_obj@data$GERMLINE_IMGT_D_MASK<-cur_clone_obj@germline
  cur_clone_obj@data$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  # marking whether the cur_clone_obj data is of at least 2 lines:
  # If only one line, it means that even though the original clone size was of more than 1 line 
  # - then all the lines were the same, and they all collapsed to one line while building a clone object.
  # So in this case - no point of building a lineage tree with one line in a clone.
  cur_clone_size<-dim(cur_clone_obj@data)[1]
  setClass("make_chaneoClone_cur_clone_class", slots=list(ChangeoClone_obj="ChangeoClone", size="numeric"))
  ret_class<-new("make_chaneoClone_cur_clone_class",ChangeoClone_obj=cur_clone_obj,size=cur_clone_size)
  return(ret_class)
}
```

#### function make_graph_cur_clone: making a graph out of ChangeoClone object:
```{r func_make_graph_cur_clone}
make_graph_cur_clone<-function(cur_clone_obj,dnapars_exec) {
  # The below line is in order to avoid warning message
  # (message: "binding factor and character vector, coercing into character vector")
  cur_clone_obj@data$SEQUENCE_ID<-as.character(cur_clone_obj@data$SEQUENCE_ID) 
  cur_clone_graph<-buildPhylipLineage(cur_clone_obj,dnapars_exec,rm_temp = TRUE)  
  # in case that the cur_clone_num does not include at least 2 unique sequences - the cur_clone_graph will be "NULL".
  #note: "N" instead of A/C/G/T does not make a sequence unique.
  return(cur_clone_graph)
}
```

#### function make_graph_df: Generating a data frame from graph object, and mering it with clone database (only for objects with more than one line):
```{r func_make_graph_df}
make_graph_df <- function(cur_clone_graph,cur_clone_obj) {
  # extracting the cur_clone_num from the inputs to function:
  cur_clone_num<-cur_clone_obj@clone
  # adding the "sequence" field - for getting the inferred sequences from the graph:
  cur_clone_graph_df<-summarizeSubtrees(cur_clone_graph,fields="sequence")
  cur_clone_merged_df<-merge(x=cur_clone_obj@data,y=cur_clone_graph_df,by.x="SEQUENCE_ID",by.y="NAME",all=T)
  # Renaming SEQUENCE_ID column to ORIG_SEQUENCE_ID, and renaming PARENT to ORIG_PARENT:
  cur_clone_merged_df$ORIG_SEQUENCE_ID<-cur_clone_merged_df$SEQUENCE_ID
  cur_clone_merged_df$ORIG_PARENT<-cur_clone_merged_df$PARENT
  
  # uniquifying some values in merged data frame, and filling some missing values:
  
  #1. Replacing inferred sequences names with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices
  cur_clone_merged_df$PARENT<-gsub(pattern="Inferred",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Inferred",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Inferred",x=V(cur_clone_graph)$label,
                                 replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  
  #2. Replacing Germline sequence name with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices:
  cur_clone_merged_df$PARENT<-gsub(pattern="Germline",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Germline_",cur_clone_num,sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Germline",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Germline_",cur_clone_num,sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Germline",x=V(cur_clone_graph)$label,
                                 replacement= paste("Germline_",cur_clone_num,sep=""))
  
  #3. Now need to fill in missing values for germline sequence and inffered sequences:
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$J_CALL<-cur_clone_obj@j_gene
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  cur_clone_merged_df$GERMLINE_IMGT_D_MASK<-cur_clone_obj@germline
  
  #4. setting a new SEQUENCE_ID column with following format:  
  #<CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.   
  #move up: cur_clone_merged_df$ORIG_SEQUENCE_ID<-cur_clone_merged_df$SEQUENCE_ID
  cur_clone_merged_df$SEQUENCE_ID <- paste(cur_clone_num,"_",c(1:length(cur_clone_merged_df$ORIG_SEQUENCE_ID)),sep="")
  cur_clone_merged_df<-mutate(cur_clone_merged_df,SEQUENCE_ID=ifelse(grepl("Germline|Inferred",ORIG_SEQUENCE_ID),
                                                      paste(cur_clone_num,"_",ORIG_SEQUENCE_ID,sep=""),SEQUENCE_ID))

  #5. Doing the same for PARENT column: 
  # Renaming PARENT column to ORIG_PARENT, and setting a new PARENT column with following format:  
  # <CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.
  # move up: cur_clone_merged_df$ORIG_PARENT<-cur_clone_merged_df$PARENT
  cur_clone_merged_df$PARENT<-cur_clone_merged_df[match(cur_clone_merged_df$ORIG_PARENT,                                                                                         cur_clone_merged_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]
 
  #6. Removing the SEQUENCE column, as it does not include sequences of germline and inferred.
  #Renaming the "sequence" column to "SEQUENCE"
  cur_clone_merged_df<-subset(cur_clone_merged_df,select=c(-SEQUENCE))
  cur_clone_merged_df<-rename(cur_clone_merged_df,SEQUENCE=sequence)

  #7. Adding the parent sequence as a new column:
  cur_clone_merged_df$PARENT_SEQUENCE<-cur_clone_merged_df[match(cur_clone_merged_df$PARENT,
                                                                 cur_clone_merged_df$SEQUENCE_ID),"SEQUENCE"]         
  # filling the parent sequece of the Germline sequence to be its own sequence (=GERMLINE_IMGT_D_MASK):
  cur_clone_merged_df<-mutate(cur_clone_merged_df,PARENT_SEQUENCE=ifelse(is.na(PARENT_SEQUENCE),
                                                                         GERMLINE_IMGT_D_MASK,PARENT_SEQUENCE))
  return(cur_clone_merged_df)
}
```

#### function draw_clone_lineage_tree: For viewing a tree plot of the clone:
```{r func_draw_clone_lineage_tree, fig.width = 15, fig.height=10}
draw_clone_lineage_tree<-function(cur_clone,clones_db) {
  dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
  ret_class<-make_chaneoClone_cur_clone(cur_clone_num = cur_clone,all_clones_db = clones_db)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  
  #print(cur_clone_obj@data)
  
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  #print(cur_clone_graph)
  #print(all_clones_merged_df[,"CLONE"==cur_clone])
  V(cur_clone_graph)$color <- "lightblue"
  #making the graph vertices show the (simple) SEQUENCE_ID
  cur_clone_only_df<-filter(all_clones_merged_df,CLONE==cur_clone)
  V(cur_clone_graph)$seq_num<-cur_clone_only_df[match(V(cur_clone_graph)$label,cur_clone_only_df$ORIG_SEQUENCE_ID),
                                                   "SEQUENCE_ID"]   
  E(cur_clone_graph)$label <- ""
  par(mar=c(0, 0, 0, 0) + 1)
  plot(cur_clone_graph, layout=layout_as_tree, edge.arrow.mode=0, vertex.frame.color="black", vertex.label.cex=0.8,
     vertex.label.color="black", vertex.size=18, vertex.label=V(cur_clone_graph)$seq_num, 
     main=paste("Lineage tree for clone ",cur_clone))
  #cur_clone_db[,c("ORIG_SEQUENCE_ID","SEQUENCE_ID","ORIG_PARENT","PARENT")]
}
```

#### looping on some clones to run functions above:
```{r loop_on_clones}
#clones_to_build_trees<-c(4070,12,259,11)
first_clone<-TRUE
#loop_start_time<-Sys.time()
for (clone_index in clones_to_build_trees) {
  dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
  #print(clone_index)
  ret_class<-make_chaneoClone_cur_clone(cur_clone_num = clone_index,all_clones_db = clones_db)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_size<-ret_class@size
  # in case  the clone size is of 1 row - skip to next clone, as no lineage tree is relevant here:
  # This also suppresses following warning:
  # "Warning in buildPhylipLineage(cur_clone_obj, dnapars_exec, rm_temp = TRUE): 
  # Clone 7781 was skipped as it does not   contain at least 2 unique sequences"
  if(nrow(cur_clone_obj@data)==1) {
    next
  }
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  #print(cur_clone_obj)
  #print("clone ",clone_index, " size: ",cur_clone_size)
  if (!is.null(cur_clone_graph)) {
    cur_clone_merged_df<-make_graph_df(cur_clone_graph,cur_clone_obj)
    if(first_clone) {
      first_clone<-FALSE
      all_clones_merged_df<-cur_clone_merged_df
    } #endif ifrst_clone
    else {
      all_clones_merged_df<-rbind(all_clones_merged_df,cur_clone_merged_df)
    }
  } # endif
} # endfor
#print all clones in all_clones_mereged_df:
print("clones in lineage trees database: ")
print(unique(all_clones_merged_df$CLONE))
#loop_end_time<-Sys.time()
#print(loop_start_time)
#print(loop_end_time)
```


