---
title: "Mutations and Lineage trees - miniproj"
author: "Milca Tarshish"
date: "9/1/2019"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Loading libraries:
```{r, message=F}
library(alakazam)
library(igraph)
library(shazam)
#library(crayon)
library(dplyr)
library(foreach)
library(doParallel)
library(ggpubr)
library(ggplot2)
rm(list=ls())
gc()
```

## Processing data: 

### Adding GERMLINE_IMGT_D_MASK, GERMLINE_IMGT and CLONE columns to database
In case the change-o database does not have columns "GERMLINE_IMGT_D_MASK", "GERMLINE_IMGT" and "CLONE", then this can be calculated by running following python script:  

C:\\Bar_Ilan_3\\projects\\mutations_and_lineage_trees_miniproj\\createGermlines_and_DefineClones.py

Note that that in case the original databse includes colunmes named N1_LENGTH and N2_LENGTH (instead of NP1_LENGTH and NP2_LENGTH) - then they must be renamed to NP1_LENGTH and NP2_LENGTH accordingly.


### Functions to be used in main flow:    

#### Function make_clones_freq_df:
Reads db, and return a list of clone numbers and their fequency:  
```{r func_makes_clones_freq_df}
make_clones_freq_df<-function(data,clone_col="CLONE") {
  clones_freq<-as.data.frame(ftable(data[,c(clone_col)]))
  names(clones_freq)<-c("CLONE","CLONE_FREQ")
  return(clones_freq)
}
```

#### Function make_clones_list:  
This function gets a db as input and generates a list of clones to run on  
The list will include each clone number only once.  
```{r func_make_clones_list}
make_clones_list<- function(db, clone_col="CLONE") {
  clones_list<-unique(db[,c(clone_col)])
  return(clones_list)
}
```


#### Function make_chaneoClone_cur_clone:  
Creating a changeoclone object for one specific clone:  
```{r func_make_chaneoClone_cur_clone}
make_chaneoClone_cur_clone <- function(db,cur_clone_num,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  cur_clone_db<-subset(db,CLONE==cur_clone_num)
  cur_clone_obj<-makeChangeoClone(data=cur_clone_db,id=id,seq=seq,germ=germ,vcall=vcall,jcall=jcall,
                                       junc_len=junc_len,clone=clone,mask_char=mask_char,
                                       max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj@data$V_CALL<-cur_clone_obj@v_gene
  cur_clone_obj@data$J_CALL<-cur_clone_obj@j_gene
  cur_clone_obj@data$CLONE<-cur_clone_obj@clone
  cur_clone_obj@data$GERMLINE_IMGT<-cur_clone_obj@germline
  cur_clone_obj@data$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  # marking the cur_clone_obj data size:
  # If only one line, it means that even though the original clone size was of more than 1 line 
  # - then all the lines were the same, and they all collapsed to one line while building a clone object.
  # special handling will be needed here.
  cur_clone_size<-dim(cur_clone_obj@data)[1]
  setClass("make_chaneoClone_cur_clone_class", slots=list(ChangeoClone_obj="ChangeoClone", size="numeric"))
  ret_class<-new("make_chaneoClone_cur_clone_class",ChangeoClone_obj=cur_clone_obj,size=cur_clone_size)
  return(ret_class)
}
```

#### function make_graph_cur_clone: 
Making a graph out of ChangeoClone object:  
```{r func_make_graph_cur_clone}
make_graph_cur_clone<-function(cur_clone_obj,dnapars_exec) {
  # The below line is in order to avoid warning message
  # (message: "binding factor and character vector, coercing into character vector")
  cur_clone_obj@data$SEQUENCE_ID<-as.character(cur_clone_obj@data$SEQUENCE_ID) 
  cur_clone_graph<-buildPhylipLineage(cur_clone_obj,dnapars_exec,rm_temp = TRUE)  
  # in case that the cur_clone_num does not include at least 2 unique sequences - the cur_clone_graph will be "NULL".
  #note: "N" instead of A/C/G/T does not make a sequence unique.
  return(cur_clone_graph)
}
```

#### function make_graph_df:  
Generating a data frame from graph object, and mering it with clone database (only for objects with more than one line):  
```{r func_make_graph_df}
make_graph_df <- function(cur_clone_graph,cur_clone_obj) {
  # extracting the cur_clone_num from the inputs to function:
  cur_clone_num<-cur_clone_obj@clone
  # generating a data frame from the clone igraph object (- for getting the inferred sequences from the graph,
  # and the parent information):
  cur_clone_graph_df<-summarizeSubtrees(cur_clone_graph,fields="sequence")
  # merging the db from clone object and from graph:
  cur_clone_merged_df<-merge(x=cur_clone_obj@data,y=cur_clone_graph_df,by.x="SEQUENCE_ID",by.y="NAME",all=T)
  # Renaming SEQUENCE_ID column to ORIG_SEQUENCE_ID, and renaming PARENT to ORIG_PARENT:
  cur_clone_merged_df$ORIG_SEQUENCE_ID<-cur_clone_merged_df$SEQUENCE_ID
  cur_clone_merged_df$ORIG_PARENT<-cur_clone_merged_df$PARENT
 
  # uniquifying some values in merged data frame, and filling some missing values:
  
  #1. Replacing inferred sequences names with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices
  cur_clone_merged_df$PARENT<-gsub(pattern="Inferred",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Inferred",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Inferred",x=V(cur_clone_graph)$label,
                                 replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  
  #2. Replacing Germline sequence name with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices:
  cur_clone_merged_df$PARENT<-gsub(pattern="Germline",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Germline_",cur_clone_num,sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Germline",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Germline_",cur_clone_num,sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Germline",x=V(cur_clone_graph)$label,
                                 replacement= paste("Germline_",cur_clone_num,sep=""))
  
  #3. Now need to fill in missing values for germline sequence and inffered sequences:
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$J_CALL<-cur_clone_obj@j_gene
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  cur_clone_merged_df$GERMLINE_IMGT<-cur_clone_obj@germline
  
  #4. setting a new SEQUENCE_ID column with following format:  
  #<CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.   
  cur_clone_merged_df$SEQUENCE_ID <-  
                              paste(cur_clone_num,"_",c(1:length(cur_clone_merged_df$ORIG_SEQUENCE_ID)),sep="")
  cur_clone_merged_df<-mutate(cur_clone_merged_df,
                              SEQUENCE_ID=ifelse(grepl("Germline|Inferred",ORIG_SEQUENCE_ID),
                                                 paste(cur_clone_num,"_",ORIG_SEQUENCE_ID,sep=""),SEQUENCE_ID))

  #5. Doing the same for PARENT column: 
  # setting a new PARENT column with following format:  
  # <CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.
  cur_clone_merged_df$PARENT<-cur_clone_merged_df[match(cur_clone_merged_df$ORIG_PARENT,                                                                    cur_clone_merged_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]
 
  #6. Removing the SEQUENCE column, as it does not include sequences of germline and inferred.
  #Renaming the "sequence" column to "SEQUENCE"
  cur_clone_merged_df<-subset(cur_clone_merged_df,select=c(-SEQUENCE))
  cur_clone_merged_df<-rename(cur_clone_merged_df,SEQUENCE=sequence)

  #7. Adding the parent sequence as a new column:
  cur_clone_merged_df$PARENT_SEQUENCE<-cur_clone_merged_df[match(cur_clone_merged_df$PARENT,
                                                                 cur_clone_merged_df$SEQUENCE_ID),"SEQUENCE"]         
  # filling the parent sequece of the Germline sequence to be its own sequence (=GERMLINE_IMGT):
  cur_clone_merged_df<-mutate(cur_clone_merged_df,PARENT_SEQUENCE=ifelse(is.na(PARENT_SEQUENCE),
                                                                         GERMLINE_IMGT,PARENT_SEQUENCE))
  return(cur_clone_merged_df)
}
```

#### function draw_clone_lineage_tree:  
For viewing a tree plot of a specific clone:  
Note that this function will give an error in case that all the sequences in the db of the specific clone  
are the same (as no lineage tree can be built on that).
```{r func_draw_clone_lineage_tree, fig.width = 15, fig.height=10}
draw_clone_lineage_tree<-function(db,cur_clone=NULL,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
  ret_class<-make_chaneoClone_cur_clone(db=db,cur_clone_num=cur_clone,id=id,seq=seq,germ=germ,                                                         vcall=vcall,jcall=jcall,junc_len=junc_len, 
                                        clone=clone,mask_char=mask_char,
                                        max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  V(cur_clone_graph)$color <- ifelse(grepl("Germline",V(cur_clone_graph)$label),"lightgreen",
                              ifelse(grepl("Inferred",V(cur_clone_graph)$label),"lightpink","lightblue"))
  #making the graph vertices show the simple SEQUENCE_ID
  cur_clone_only_df<-filter(all_clones_merged_df,CLONE==cur_clone)
  #V(cur_clone_graph)$seq_num<-cur_clone_only_df[match(V(cur_clone_graph)$label,
  #                                                    cur_clone_only_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]   
  E(cur_clone_graph)$label <- ""
  par(mar=c(0, 0, 0, 0) + 1)
  plot(cur_clone_graph, layout=layout_as_tree, edge.arrow.mode=0, 
       vertex.frame.color="black", vertex.label.cex=0.8,
       vertex.label.color="black", vertex.size=18, vertex.label=V(cur_clone_graph)$seq_num, 
       main=paste("Lineage tree for clone ",cur_clone))
  legend("topright", c("Germline", "Inferred", "Sample"), 
       fill=c("lightgreen", "lightpink", "lightblue"), cex=0.75)
}
```

#### function make_region:  
Getting as input a JUNCTION_LENGTH, SEQUENCE_IMGT, reg_type.  
and outputing a RegionDefinition object that includes following regions:   
If reg_type="ALL", the regions will be as follows:  
- FWR1: Bases	1 to 78     (based on IMGT_V_BY_REGIONS definitions)  
- CDR1: Bases	79 to 114   (based on IMGT_V_BY_REGIONS definitions) 
- FWR2: Bases	115 to 165  (based on IMGT_V_BY_REGIONS definitions)  
- CDR2: Bases	166 to 195  (based on IMGT_V_BY_REGIONS definitions)  
- FWR3: Bases	196 to 312  (based on IMGT_V_BY_REGIONS definitions)
- CDR3: Bases	313 to (313+JUNCTION_LENGTH-6) - since junction sequnece includes (on the left) the last codon from FWR3, and (on the right) the first codon from FWR4.  
- FWR4: Bases	(313+JUNCTION_LENGTH-6+1) to SEQUENCE_LENGTH.  
If reg_type="CDR_FWR", the regions will be same as above, except that all FWR1/2/3/4 will be named "FWR",  
and all CDR1/2/3 will be named "CDR"
```{r func_make_region}
make_region <- function(JUNCTION_LENGTH,SEQUENCE_IMGT,reg_type="ALL") {
  # First need to extract sequence length from sequence:
  SEQ_LEN<-nchar(SEQUENCE_IMGT)
  name<-"IMGT_FULL_BY_REGIONS"
  description<-"IMGT numbering scheme defining the V(D)J segment by individual CDR and FWR regions, including CDR3 and FWR4"
  boundaries<-factor(IMGT_V_BY_REGIONS@boundaries  ,levels=c(levels(IMGT_V_BY_REGIONS@boundaries),"CDR3","FWR4"))
  boundaries[313:(313+as.integer(JUNCTION_LENGTH)-6-1)]<-factor("CDR3")
  boundaries[(313+as.integer(JUNCTION_LENGTH)-6):SEQ_LEN]<-factor("FWR4")
  seqLength<-SEQ_LEN
  regions<-c("CDR1","CDR2","CDR3","FWR1","FWR2","FWR3","FWR4")
  labels<-c("CDR1_R","CDR1_S","CDR2_R","CDR2_S","CDR3_R","CDR3_S","FWR1_R","FWR1_S","FWR2_R","FWR2_S","FWR3_R","FWR3_S","FWR4_R","FWR4_S")
  if(reg_type=="CDR_FWR") {
    name<-"IMGT_FULL_BY_CDR_FWR"
    description<-"IMGT numbering scheme defining the V(D)J segment only by CDR/FWR regions, including CDR3 and FWR4"
    boundaries<-gsub(pattern="FWR.",replacement = "FWR", x=boundaries,perl=TRUE)
    boundaries<-gsub(pattern="CDR.",replacement = "CDR", x=boundaries,perl=TRUE)
    boundaries<-factor(boundaries,levels=c("FWR","CDR"))
    regions<-c("CDR","FWR")
    labels<-c("CDR_R","CDR_S","FWR_R","FWR_S")
  }
  citation<-"http://www.imgt.org/IMGTScientificChart/Nomenclature/IMGT-FRCDRdefinition.html"
  ret_class<-new("RegionDefinition",name=name,description=description,boundaries=boundaries,
                                    seqLength=seqLength,regions=regions,labels=labels,
                                    citation=citation)
  return(ret_class)
}
```

#### function get_clone_region:  
This function gets as input a clone number and a data frame with sequences and their clone number,  
And returns the RegionDefinition object of type IMGT_FULL_BY_REGIONS for this specific clone.  
The function gets as input also the column name of the clone and sequence in the data frame.
Note that the region definition is same for all sequences in clone - so doing it based on first sequence in clone.  
```{r func_get_clone_region}
get_clone_region <- function(clone_num,db,seq_col="SEQUENCE",junc_len_col="JUNCTION_LENGTH",
                             clone_col="CLONE",reg_type="ALL") {
  # getting one of the sequences of the specific clone: 
  # clone_col1<-as.symbol(clone_col)
  clone_db<-filter(db,(!!as.name(clone_col))==clone_num)
  #clone_db<-filter(db,CLONE==clone_num)
  seq<-clone_db[1,seq_col]
  junc_len<-clone_db[1,junc_len_col]
  reg<-make_region(JUNCTION_LENGTH = junc_len, SEQUENCE_IMGT = seq, reg_type=reg_type)
  return(reg)
}
```

#### function make_regions_dict:  
This function gets as input a data frame, and returns a named list.  The list elements names are all the  
numbers in the data frame, and the list elements are 2 region definitions objects for each clone:  
The first object in each list element will be region of type "IMGT_FULL_BY_REGIONS", and the 2nd will be of type "IMGT_FULL_BY_CDR_FWR".  
```{r func_make_regions_dict}
make_regions_dict<-function(db,seq_col="SEQUENCE",junc_len_col="JUNCTION_LENGTH",clone_col="CLONE") {
  # First stage is to create a temporary db that includes one row per clone, as only one line per clone is needed to compute its regions definitions. This row will include only relevant columns to compute the regions.
  # First - removing unrelated columns:
  db_tmp<-subset(db,select=c(seq_col,junc_len_col,clone_col))
  # now need to remove lines, such that each clone will have only one line:  
  db_tmp$DUPLICATED_CLONE<-duplicated(db_tmp$CLONE)
  db_tmp<-filter(db_tmp,DUPLICATED_CLONE==FALSE)
  # now prepare the lists. First - define their elements names as the clones numbers:  
  clones_regions_list_ALL<-vector(mode="list", length=length(db_tmp$DUPLICATED_CLONE))
  clones_regions_list_CDR_FWR<-vector(mode="list", length=length(db_tmp$DUPLICATED_CLONE))
  names(clones_regions_list_ALL)<-db_tmp$CLONE
  names(clones_regions_list_CDR_FWR)<-db_tmp$CLONE
  # setting a list where each element is the IMGT_FULL_BY_REGIONS region definition:
  clones_regions_list_ALL<-sapply(X=db_tmp$CLONE,FUN=get_clone_region,db=db_tmp,seq_col=seq_col,
                                  junc_len_col=junc_len_col,
                                  clone_col=clone_col,reg_type="ALL")
  # setting a list where each element is the IMGT_FULL_BY_CDR_FWR region definition:
  clones_regions_list_CDR_FWR<-sapply(X=db_tmp$CLONE,FUN=get_clone_region,db=db_tmp,seq_col=seq_col,
                              junc_len_col=junc_len_col,
                              clone_col=clone_col,reg_type="CDR_FWR")
  # merging 2 lists as they have same names:
  clones_regions_list<-mapply(c,clones_regions_list_ALL,clones_regions_list_CDR_FWR,SIMPLIFY = FALSE)
  names(clones_regions_list)<-names(clones_regions_list_ALL)
  return(clones_regions_list)
}
```

#### function observedMutations_L:  
Very similar to observedMutations function, except that it runs with regard to parent sequence in lineage tree,  
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_observedMutations_L}
observedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", refColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE", reg_type="ALL", mutationDefinition = NULL, 
                                ambiguousMode = c("eitherOr", "and"), 
                                frequency = FALSE, combine = FALSE, nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function observedMutations with its own regionDefinition.
  # For all clones - the refColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"],
                               reg_type=reg_type)
    clone_observeedMutations_db<-observedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn=refColumn,
                                                   regionDefinition=cur_clone_reg,                                              
                                                   mutationDefinition=mutationDefinition,
                                                   ambiguousMode=ambiguousMode,
                                                   frequency=frequency,combine=combine,nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      observeedMutations_db<-clone_observeedMutations_db
      first_clone<-0
    }
    else {
      observeedMutations_db<-rbind(observeedMutations_db,clone_observeedMutations_db)
    }
  } # end of for loop
  return(observeedMutations_db)
} # end of function
```

#### function expectedMutations_L:  
Very similar to expectedMutations function, except that it runs with regard to parent sequence in lineage tree,
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_expectedMutations_L}
expectedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", refColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE",reg_type="ALL", targetingModel = HH_S5F,
                                mutationDefinition = NULL, nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function expectedMutations with its own regionDefinition.
  # For all clones - the refColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"],
                               reg_type=reg_type)
    clone_expectedMutations_db<-expectedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn =refColumn,
                                                   targetingModel=targetingModel,
                                                   regionDefinition=cur_clone_reg,
                                                   mutationDefinition=mutationDefinition,
                                                   nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      expectedMutations_db<-clone_expectedMutations_db
      first_clone<-0
    }
    else {
      expectedMutations_db<-rbind(expectedMutations_db,clone_expectedMutations_db)
    }
  } # end of for loop
  return(expectedMutations_db)
} # end of function
```
#### Function collapse_one_clone:  
This function is the same as original collapseClones function, except that it works on one clone only.  
```{r func_collapse_one_clone}
collapse_one_clone<-function(clone_num,db,junc_len_col="JUNCTION_LENGTH", cloneColumn = "CLONE",
                             sequenceColumn = "SEQUENCE_IMGT", reg_type = "ALL",
                             germlineColumn = "GERMLINE_IMGT_D_MASK", muFreqColumn = NULL, 
                             method=c("mostCommon","thresholdedFreq","catchAll","mostMutated","leastMutated"),
                             minimumFrequency = NULL,includeAmbiguous = FALSE, breakTiesStochastic = FALSE,
                             breakTiesByColumns = NULL, expandedDb = FALSE, nproc = 1) {
  clone_db<-filter(db,(!!as.name(cloneColumn))==clone_num)
  clone_reg_def<-get_clone_region(clone_num=clone_num,db=clone_db,seq_col=sequenceColumn,
                                  junc_len_col=junc_len_col,clone_col=cloneColumn,reg_type=reg_type)
  collapsed_clone<-collapseClones(db=clone_db,cloneColumn = cloneColumn,sequenceColumn = sequenceColumn,
                                  germlineColumn = germlineColumn, muFreqColumn = muFreqColumn, 
                                  regionDefinition = clone_reg_def, method = method, 
                                  minimumFrequency = minimumFrequency,includeAmbiguous = includeAmbiguous,
                                  breakTiesStochastic = breakTiesStochastic, 
                                  breakTiesByColumns=breakTiesByColumns, expandedDb=expandedDb, nproc=nproc)
  return(collapsed_clone)
}
```

#### Function collapseClones_L:  
This is the same as original collapseClones function, except that the region definition will be set per clone in the database, in order to include CDR3 and FWR4 in the region definition (Note: in original function collapseClones - one region definition is defined for all clones in db).  
```{r func collapseClones_L}
collapseClones_L<-function(db,cloneColumn = "CLONE", junc_len_col="JUNCTION_LENGTH",
                           sequenceColumn = "SEQUENCE_IMGT", reg_type="ALL", 
                           germlineColumn = "GERMLINE_IMGT_D_MASK", muFreqColumn = NULL, 
                           method = c("mostCommon","thresholdedFreq","catchAll","mostMutated","leastMutated"),
                           minimumFrequency = NULL,includeAmbiguous = FALSE, breakTiesStochastic = FALSE,
                           breakTiesByColumns = NULL, expandedDb = FALSE, nproc = 1) {
  clones_list<-make_clones_list(db=db,clone_col=cloneColumn)
  collapsed_clones_list<-sapply(X = clones_list,FUN = collapse_one_clone,
                              db=db,junc_len_col=junc_len_col, cloneColumn = cloneColumn,
                              sequenceColumn = sequenceColumn, reg_type = reg_type,
                              germlineColumn = germlineColumn, muFreqColumn = muFreqColumn, 
                              method=method,
                              minimumFrequency = minimumFrequency,includeAmbiguous = includeAmbiguous,
                              breakTiesStochastic = breakTiesStochastic,
                              breakTiesByColumns = breakTiesByColumns, expandedDb = expandedDb, 
                              nproc = nproc,simplify = FALSE, USE.NAMES = FALSE)
  
  # transposing result rows and columns and coercing to data frame
  #collapsed_clones_db<-as.data.frame(t(collapsed_clones_db))
  collapsed_clones_db<-do.call("rbind",collapsed_clones_list)
  
  return(collapsed_clones_db)
}
```

### Function calcBaseline_one_line:  
This function calculates baseline for one clone in db.  
It will first calculate the specific clone region definition (which is specific to the clone).  
```{func_calcBaseline_one_clone}
calcBaseline_one_clone<-function(clone_num,db, sequenceColumn = "SEQUENCE_IMGT", clone_col="CLONE",
                                 junc_len_col="JUNCTION_LENGTH",
                                 germlineColumn = "GERMLINE_IMGT",
                                 testStatistic = c("local", "focused", "imbalanced"), 
                                 regionDefinition = c("ALL","CDR_FWR"),
                                 targetingModel = HH_S5F, 
                                 mutationDefinition = NULL,
                                 calcStats = FALSE, 
                                 nproc = 1) {
  clone_db<-filter(db,(!!as.name(clone_col))==clone_num)
  reg_def<-get_clone_region(clone_num=clone_num, db=db, 
                              seq_col=sequenceColumn,
                              junc_len_col=junc_len_col,
                              clone_col=clone_col,reg_type=regionDefinition)
  clone_baseline<-calcBaseline(db=clone_db,sequenceColumn = sequenceColumn,
                               germlineColumn = germlineColumn, testStatistic = testStatistic,
                               regionDefinition = reg_def,
                               targetingModel = targetingModel,
                               mutationDefinition = mutationDefinition,
                               calcStats = calcStats, nproc = nproc)
  return(clone_baseline)
}
```

#### Function calcBaseline_L:  
This function calculates baseline for many sequences in a db, while each sequence is of different junction length, and thus may have a different region definition.  
This function output is a Baseline_L object class, which is very similar to an object of class Baseline,  
except for the slot regionDefinition which is now a list of RegionDefinition objects, and not just one such.  
Basically, this function uses the function calcBaseline_one_clone to calculate a "clone baseline" for each clone number, and then it concatenates (for each slot separately) all the "clone baseline" same slots to one.
For example:  
db slot is concatenation (rbind) of all the db slots of all "clone baselines" db slots.  
same for all following slots:
- db
- numbOfSeqs
- binomK
- binomN
- binomP
- pdfs
- stats
The following slots will be accumulated to form a new slot which is a list (not rbind/concatenate):  
- regionDefinition
- 
The following slots will remain with no change:
- description
- testStatistic
- regions

```{r func_calcBaseline_L}
calcBaseline_L<-function(db, sequenceColumn = "CLONAL_IMGT",germlineColumn = "GERMLINE_IMGT",
                         testStatistic = c("local","focused", "imbalanced"),clone_col="CLONE", 
                         regionDefinition = c("ALL","CDR_FWR"),targetingModel = HH_S5F, 
                         mutationDefinition = NULL, calcStats = FALSE, nproc = 1) {
  clones_list<-make_clones_list(db=db, clone_col=clone_col)
  
  # bellow 2 lines are for running faster in parallel cores:
  cl <- makeCluster(detectCores(), type='PSOCK')
  registerDoParallel(cl)

  clones_baseline_list<-sapply(X=clones_list,FUN=calcBaseline_one_clone,db=db,
                                  sequenceColumn = sequenceColumn, clone_col=clone_col,
                                  germlineColumn = germlineColumn,
                                  testStatistic = testStatistic,
                                  regionDefinition = regionDefinition,
                                  targetingModel = targetingModel,
                                  mutationDefinition = mutationDefinition,
                                  calcStats = calcStats, nproc = nproc)
  
  # now setting the different slots of the result baseline class:
  # description:
  baseline_description<-"Baseline generated based on function calcBaseline_L, where each clone's region definition is calculated separately upon its length"
  
  #testStatistic:
  baseline_testStatistic<-clones_baseline_list[[1]]@testStatistic
  
  #regions:
  baseline_regions<-clones_baseline_list[[1]]@regions
  
  # db:
  db_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@db,
                  USE.NAMES = FALSE,simplify = FALSE)
  
  baseline_db<-do.call("rbind",db_list)
  
  #numbOfSeqs:
  numbOfSeqs_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@numbOfSeqs,
                          USE.NAMES = FALSE,simplify = FALSE)
  baseline_numbOfSeqs<-do.call("rbind",numbOfSeqs_list)
  rownames(baseline_numbOfSeqs)<-as.character(c(1:dim(baseline_numbOfSeqs)[1]))
  
  #binomK:
  binomK_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@binomK,
                      USE.NAMES = FALSE, simplify = FALSE)
  baseline_binomK<-do.call("rbind",binomK_list)
  rownames(baseline_binomK)<-as.character(c(1:dim(baseline_binomK)[1]))
  
  #binomN:
  binomN_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@binomN,
                      USE.NAMES = FALSE, simplify = FALSE)
  baseline_binomN<-do.call("rbind",binomN_list)
  rownames(baseline_binomN)<-as.character(c(1:dim(baseline_binomN)[1]))
  
  #binomP:
  binomP_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@binomP,
                      USE.NAMES = FALSE, simplify = FALSE)
  baseline_binomP<-do.call("rbind",binomP_list)
  rownames(baseline_binomP)<-as.character(c(1:dim(baseline_binomP)[1]))
  
  #pdfs:
  # First - setting an empty list with proper length and names:
  baseline_pdfs.names <- names(clones_baseline_list[[1]]@pdfs)
  baseline_pdfs <- vector("list", length(baseline_pdfs.names))
  names(baseline_pdfs) <- baseline_pdfs.names
  # now each list element is a matrix:
  for (pdf in names(clones_baseline_list[[1]]@pdfs)) {
    pdf_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@pdfs[[pdf]],
                     USE.NAMES = FALSE, simplify = FALSE)
    baseline_pdfs[[pdf]]<-do.call("rbind",pdf_list)
  }  
  
  #stats:
  stats_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@stats,
                         USE.NAMES = FALSE, simplify = FALSE)
  baseline_stats<-do.call("rbind",stats_list)
  
  #regionDefinition: This is the only slot in output baseline whihc is not the same class as in standard
  #                 calcBaseline output, as it is different for each clone. So the class here is a list
  #                 of regionDefinition objects (and not just one such) 
  regionDefinition_list<-sapply(X=clones_list,FUN=function(x2) clones_baseline_list[[x2]]@regionDefinition,
                                USE.NAMES = FALSE, simplify = FALSE)
  names(regionDefinition_list)<-clones_list
  
  # setting a new class named Baseline_L. Same slots as Baseline, all slots (except regionDefinition) are of same type as Baseline slots. regionDefinition slot here is a list of RegionDefinition, while in Baseline it is one RegionDefinition only.
  setClass("Baseline_L", slots=list(description="character", db="data.frame", regionDefinition="list",
                                    testStatistic="character", regions="character", numbOfSeqs="matrix",
                                    binomK="matrix", binomN="matrix", binomP="matrix",
                                    pdfs="list", stats="data.frame"))

  ret_class<-new("Baseline_L",description=baseline_description, db=baseline_db, 
                 regionDefinition=regionDefinition_list, testStatistic=baseline_testStatistic,
                 regions=baseline_regions, numbOfSeqs=baseline_numbOfSeqs, 
                 binomK=baseline_binomK, binomN=baseline_binomN, binomP=baseline_binomP,
                 pdfs=baseline_pdfs, stats=baseline_stats)  
  # going back to none paralel mode:
  registerDoSEQ()
  return(ret_class)
}




```

#### Function groupBaselin_L:  
This is the same as function groupBAseline, excepts that it receives a Baseline_L object instead of a  
Baseline object as input.  
```{r func_groupBaseline_L}
groupBaseline_L<-function(baseline_L, groupBy, nproc=1) {
  ret_class<-new("Baseline",description=baseline_L@description, db=baseline_L@db, 
                 regionDefinition=baseline_L@regionDefinition[[1]], testStatistic=baseline_L@testStatistic,
                 regions=baseline_L@regions, numbOfSeqs=baseline_L@numbOfSeqs, 
                 binomK=baseline_L@binomK, binomN=baseline_L@binomN, binomP=baseline_L@binomP,
                 pdfs=baseline_L@pdfs, stats=baseline_L@stats)
  baseline1<-groupBaseline(ret_class,groupBy = groupBy, nproc=nproc)
  return(baseline1)
}
```


### Processing data prior to data analysis: Using all functions above on database:  
```{r data_process}
# 1. Loading data from HCV_B database:  
file_pointer<-"C:\\Bar Ilan 3 data - not backed up\\HCV_B\\CI10_rename_p1_p2_germ-pass_clone-pass_germ-pass.tab"
clones_db<-read.csv(file_pointer, header=TRUE,sep='\t')
dim(clones_db)

# 2. Removing from db sequences that their IMGT sequence is shorter than 312 nucleotides.
#    The reason for this is that running Expected mutations on them does not run properly, as they are missing full
#    range of FWR1/CDR1/FWR2/CDR2/FWR3 which is 312 nucleotides (not sure at all why they even exist in the db). 
clones_db<-subset(clones_db,nchar(as.character(SEQUENCE_IMGT))>=312)

# 3. create a list of clones to loop on:  
clones_to_build_trees<-make_clones_list(clones_db)

# 4. Loop on all clones in db above:
#remove from db the SEQUENCE_INPUT column - as all analysis needs to be done on SEQUENCE_IMGT column
clones_db<-subset(clones_db,select=-c(SEQUENCE_INPUT))
first_clone<-TRUE
first_size_1_clone<-TRUE
#loop_start_time<-Sys.time()
dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
size_1_clones<-NULL
for (clone_index in clones_to_build_trees) {
  ret_class<-make_chaneoClone_cur_clone(db = clones_db,cur_clone_num = clone_index)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_size<-ret_class@size
  # in case  the clone size is of 1 row - keep them in separate db and  skip to next clone, as they will need special care later:
  # This also suppresses following warning:
  # "Warning in buildPhylipLineage(cur_clone_obj, dnapars_exec, rm_temp = TRUE): 
  if(cur_clone_size==1) {
    size_1_clones<-c(size_1_clones,clone_index)
    if(first_size_1_clone){
      size_1_clone_db<-cur_clone_obj@data
      first_size_1_clone<-FALSE
    }
    else {
      size_1_clone_db<-rbind(size_1_clone_db,cur_clone_obj@data)
    }
    next
  }
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  if (!is.null(cur_clone_graph)) { 
    cur_clone_merged_df<-make_graph_df(cur_clone_graph,cur_clone_obj)
    if(first_clone) {
      first_clone<-FALSE
      all_clones_merged_df<-cur_clone_merged_df
    } #endif first_clone
    else {
      all_clones_merged_df<-rbind(all_clones_merged_df,cur_clone_merged_df)
    }
  } # endif
} # endfor

# 5. Taking care of clones of size 1:
#    preparing a db with columns same as final db (all_clones_merged_df) - that includes the clones of size 1:
#     They can originate from 2 reasons:
#        a. clones that in original db had one read only.
#        b. clones that had more than one read, but after running makeChangeoClone - all read collapsed all to one line.
#    These clones of size 1 will be added later to final db.
oneread_clones_db_new<-setNames(data.frame(matrix(ncol = length(names(all_clones_merged_df)), 
                                                  nrow = length(size_1_clones))), 
                                names(all_clones_merged_df))
oneread_clones_db_new[,"CLONE"]                  <-size_1_clone_db[,"CLONE"]
oneread_clones_db_new[,"V_CALL"]                 <-size_1_clone_db[,"V_CALL"]
oneread_clones_db_new[,"J_CALL"]                 <-size_1_clone_db[,"J_CALL"]
oneread_clones_db_new[,"GERMLINE_IMGT"]          <-size_1_clone_db[,"GERMLINE_IMGT"]
oneread_clones_db_new[,"JUNCTION_LENGTH"]        <-size_1_clone_db[,"JUNCTION_LENGTH"]
oneread_clones_db_new[,"SEQUENCE"]               <-size_1_clone_db[,"SEQUENCE"]
oneread_clones_db_new[,"ORIG_SEQUENCE_ID"]       <-size_1_clone_db[,"SEQUENCE_ID"]
oneread_clones_db_new[,"PARENT_SEQUENCE"]        <-size_1_clone_db[,"GERMLINE_IMGT"]
oneread_clones_db_new[,"PARENT"]                 <-paste(size_1_clone_db[,"CLONE"],"_Germline",sep="")
oneread_clones_db_new[,"SEQUENCE_ID"]            <-paste(size_1_clone_db[,"CLONE"],"_1",sep="")

# 6. adding for each one read clone - a new line of its germline:
oneread_clones_db_germ<-oneread_clones_db_new
oneread_clones_db_germ$SEQUENCE_ID<-oneread_clones_db_new$PARENT
oneread_clones_db_germ$SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT
oneread_clones_db_germ$PARENT<-"NA"
oneread_clones_db_germ$ORIG_PARENT<-"Germline"
oneread_clones_db_germ$PARENT_SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT
oneread_clones_db_new<-rbind(oneread_clones_db_new,oneread_clones_db_germ)
oneread_clones_db_new$SEQUENCE<-as.character(oneread_clones_db_new$SEQUENCE)
oneread_clones_db_new$V_CALL<-as.character(oneread_clones_db_new$V_CALL)
oneread_clones_db_new$J_CALL<-as.character(oneread_clones_db_new$J_CALL)
oneread_clones_db_new$CLONE<-as.character(oneread_clones_db_new$CLONE)


# 7. adding the one read clone db to the main db, and removing unused variables to clear memory:
none_singletone_db<-all_clones_merged_df
all_clones_merged_df<-rbind(all_clones_merged_df,oneread_clones_db_new)
gc()
```

### Data analysis 1: Comparing PDFs of 2 methods of grouping:  
1. PDFs using consensus clones.  
2. PDFs using parents sequences.  
```{r data_analysis_1}
#1.  Calculating "consensus" sequence through "collapasClones" on all clones, and drawing PDF: 
#    (Note: cannot use all possible :methods" due to some NA in db)
all_clones_merged_df$ORIG_SEQUENCE_ID<-as.character(all_clones_merged_df$ORIG_SEQUENCE_ID)
collapsed_db<-collapseClones_L(db=all_clones_merged_df, 
                               sequenceColumn = "SEQUENCE", reg_type="ALL",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline<-calcBaseline_L(db=collapsed_db,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "ALL")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline@db$SAME<-"same"
collapsed_db_group_baseline<-groupBaseline_L(baseline_L=collapsed_db_baseline,groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
collapsed_db2<-collapseClones_L(db=all_clones_merged_df, 
                               sequenceColumn = "SEQUENCE", reg_type="CDR_FWR",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline2<-calcBaseline_L(db=collapsed_db2,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "CDR_FWR")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline2@db$SAME<-"same"
collapsed_db_group_baseline2<-groupBaseline_L(baseline_L=collapsed_db_baseline2,groupBy = "SAME")


#2. Calculating baseline for all reads - when ref sequence is the parent sequence, and not the germline sequence.
#expanding memory alocation:
gc()
memory.limit(size = 15000)
parent_db_baseline<-calcBaseline_L(db=all_clones_merged_df,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "ALL")
parent_db_baseline@db$SAME<-"same"
parent_db_group_baseline<-groupBaseline_L(baseline_L = parent_db_baseline, groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
parent_db_baseline2<-calcBaseline_L(db=all_clones_merged_df,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "CDR_FWR")
gc()
parent_db_baseline2@db$SAME<-"same"
parent_db_group_baseline2<-groupBaseline_L(baseline_L = parent_db_baseline2, groupBy = "SAME")

#3. plottting all PDFs:
g11<-plotBaselineDensity(collapsed_db_group_baseline,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF consensus with region ALL")
g11<-g11+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g12<-plotBaselineDensity(collapsed_db_group_baseline2,idColumn = "SAME",sigmaLimits = c(-0.2,0.3),
                    title="PDF consensus with region CDR_FWR")
g12<-g12+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g21<-plotBaselineDensity(parent_db_group_baseline,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF parents with region ALL")
g21<-g21+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g22<-plotBaselineDensity(parent_db_group_baseline2,idColumn = "SAME",sigmaLimits = c(-0.2,0.3),
                    title="PDF parents with region CDR_FWR")
g22<-g22+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))
ggarrange(g11,g12 ,g21 ,g22, ncol = 2, nrow = 2)
```


### Data analysis 2: same as Data analysis 1, but only on none-singletone reads.  
The motivation here is to have a stronger difference between 2 methods bellow, as singletone reads will  
show (as proven later below) - that singletone reads behave the same in both methods: 
1. PDFs using consensus clones.  
2. PDFs using parents sequences.  
```{r data_analysis_2}
#1.  Calculating "consensus" sequence through "collapasClones" on all clones, and drawing PDF: 
#    (Note: cannot use all possible :methods" due to some NA in db)
collapsed_db_nonest<-collapseClones_L(db=none_singletone_db, 
                               sequenceColumn = "SEQUENCE", reg_type="ALL",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline_nonest<-calcBaseline_L(db=collapsed_db_nonest,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "ALL")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline_nonest@db$SAME<-"same"
collapsed_db_group_baseline_nonest<-groupBaseline_L(baseline_L=collapsed_db_baseline_nonest,groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
collapsed_db2_nonest<-collapseClones_L(db=none_singletone_db, 
                               sequenceColumn = "SEQUENCE", reg_type="CDR_FWR",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline2_nonest<-calcBaseline_L(db=collapsed_db2_nonest,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "CDR_FWR")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline2_nonest@db$SAME<-"same"
collapsed_db_group_baseline2_nonest<-groupBaseline_L(baseline_L=collapsed_db_baseline2_nonest,groupBy = "SAME")


#2. Calculating baseline for all reads - when ref sequence is the parent sequence, and not the germline sequence.
#expanding memory alocation:
gc()
memory.limit(size = 15000)
parent_db_baseline_nonest<-calcBaseline_L(db=none_singletone_db,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "ALL")
parent_db_baseline_nonest@db$SAME<-"same"
parent_db_group_baseline_nonest<-groupBaseline_L(baseline_L = parent_db_baseline_nonest, groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
parent_db_baseline2_nonest<-calcBaseline_L(db=none_singletone_db,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "CDR_FWR")
gc()
parent_db_baseline2_nonest@db$SAME<-"same"
parent_db_group_baseline2_nonest<-groupBaseline_L(baseline_L = parent_db_baseline2_nonest, groupBy = "SAME")

#3. plottting all PDFs:
gn_11<-plotBaselineDensity(collapsed_db_group_baseline_nonest,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF consensus with region ALL \n data=none singletone clones")
gn_11<-gn_11+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

gn_12<-plotBaselineDensity(collapsed_db_group_baseline2_nonest,idColumn = "SAME",sigmaLimits = c(-0.5,0.2),
                    title="PDF consensus with region CDR_FWR \n data=none singletone clones")
gn_12<-gn_12+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

gn_21<-plotBaselineDensity(parent_db_group_baseline_nonest,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF parents with region ALL \n data=none singletone clones")
gn_21<-gn_21+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

gn_22<-plotBaselineDensity(parent_db_group_baseline2_nonest,idColumn = "SAME",sigmaLimits = c(-0.5,0.2),
                    title="PDF parents with region CDR_FWR \n data=none singletone clones")
gn_22<-gn_22+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))
ggarrange(gn_11,gn_12 ,gn_21 ,gn_22, ncol = 2, nrow = 2)
```

```{r}
#Ploting Error Bar Charts for above none-singletone:
collaped_stats_reg_ALL<-collapsed_db_group_baseline_nonest@stats
collaped_stats_reg_ALL$BASELINE_METHOD<-"Consensus"

collaped_stats_reg_CDR_FWR<-collapsed_db_group_baseline2_nonest@stats
collaped_stats_reg_CDR_FWR$BASELINE_METHOD<-"Consensus"

parent_stats_reg_ALL<-parent_db_group_baseline_nonest@stats
parent_stats_reg_ALL$BASELINE_METHOD<-"Parent"

parent_stats_reg_CDR_FWR<-parent_db_group_baseline2_nonest@stats
parent_stats_reg_CDR_FWR$BASELINE_METHOD<-"Parent"

stats_reg_ALL<-rbind(collaped_stats_reg_ALL,parent_stats_reg_ALL)
stats_reg_CDR_FWR<-rbind(collaped_stats_reg_CDR_FWR,parent_stats_reg_CDR_FWR)



base_theme <- theme_bw() + theme(panel.background = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
                                 panel.border = element_rect(color = "black", size = 0.5)) + 
              theme(strip.background = element_rect(fill = "white",color = "black", size = 0.5)) + theme(axis.title.x = element_blank(),
                                                                                                         axis.text.x = element_blank(),
                                                                                                         axis.ticks.x = element_blank()) + 
              theme(legend.position = "top") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

g_eb_ALL<-ggplot(stats_reg_ALL, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_ALL<-g_eb_ALL+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_ALL<-g_eb_ALL + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_ALL<-g_eb_ALL +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_ALL<-g_eb_ALL+base_theme
g_eb_ALL<-g_eb_ALL+ggtitle('Baseline results for methods "Consensus" and "Parent"\n  region type "ALL", data HCV CI10 none-singletone,  "local" test')
g_eb_ALL<-g_eb_ALL +ylab(expression(Sigma))
g_eb_ALL

g_eb_CDR_FWR<-ggplot(stats_reg_CDR_FWR, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_CDR_FWR<-g_eb_CDR_FWR+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_CDR_FWR<-g_eb_CDR_FWR + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_CDR_FWR<-g_eb_CDR_FWR +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_CDR_FWR<-g_eb_CDR_FWR+base_theme
g_eb_CDR_FWR<-g_eb_CDR_FWR+ggtitle('Baseline results for methods "Consensus" and "Parent"\n  region type "CDR_FWR", data HCV CI10 none-singletone, "local" test')
g_eb_CDR_FWR<-g_eb_CDR_FWR +ylab(expression(Sigma)) 
g_eb_CDR_FWR

```
#### Data analysis 3:  Same as Data Analysis 1, but on clones with up to 10 mutations: 
Same as data analysis 1, but filtering to clones with up to 10 mutations on all reads.  
```{r data_analysis_4}
#1.  Calculating "consensus" sequence through "collapasClones" on all clones, and drawing PDF: 
#    (Note: cannot use all possible :methods" due to some NA in db)
all_clones_merged_df$ORIG_SEQUENCE_ID<-as.character(all_clones_merged_df$ORIG_SEQUENCE_ID)
collapsed_db<-collapseClones_L(db=all_clones_merged_df, 
                               sequenceColumn = "SEQUENCE", reg_type="ALL",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline<-calcBaseline_L(db=collapsed_db,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "ALL")
collapsed_db_baseline@db<-mutate(collapsed_db_baseline@db,MU_COUNT=MU_COUNT_CDR1_S+MU_COUNT_CDR1_R+MU_COUNT_CDR2_S+MU_COUNT_CDR2_R+MU_COUNT_CDR3_S+MU_COUNT_CDR3_R+MU_COUNT_FWR1_S+MU_COUNT_FWR1_R+MU_COUNT_FWR2_S+MU_COUNT_FWR2_R+MU_COUNT_FWR3_S+MU_COUNT_FWR3_R+MU_COUNT_FWR4_S+MU_COUNT_FWR4_R)
collapsed_db_baseline@db<-filter(collapsed_db_baseline@db,MU_COUNT<=10)
collapsed_db_baseline@db$SAME<-"same"
collapsed_db_group_baseline<-groupBaseline_L(baseline_L=collapsed_db_baseline,groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
collapsed_db2<-collapseClones_L(db=all_clones_merged_df, 
                               sequenceColumn = "SEQUENCE", reg_type="CDR_FWR",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline2<-calcBaseline_L(db=collapsed_db2,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "CDR_FWR")
collapsed_db_baseline2@db<-mutate(collapsed_db_baseline2@db,MU_COUNT=MU_COUNT_CDR_R+MU_COUNT_CDR_S+MU_COUNT_FWR_R+MU_COUNT_FWR_S)
collapsed_db_baseline2@db<-filter(collapsed_db_baseline2@db,MU_COUNT<=10)
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline2@db$SAME<-"same"
collapsed_db_group_baseline2<-groupBaseline_L(baseline_L=collapsed_db_baseline2,groupBy = "SAME")


#2. Calculating baseline for all reads - when ref sequence is the parent sequence, and not the germline sequence.
#expanding memory alocation:
gc()
memory.limit(size = 15000)
parent_db_baseline<-calcBaseline_L(db=all_clones_merged_df,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "ALL")
parent_db_baseline@db<-mutate(parent_db_baseline@db,MU_COUNT=MU_COUNT_CDR1_S+MU_COUNT_CDR1_R+MU_COUNT_CDR2_S+MU_COUNT_CDR2_R+MU_COUNT_CDR3_S+MU_COUNT_CDR3_R+MU_COUNT_FWR1_S+MU_COUNT_FWR1_R+MU_COUNT_FWR2_S+MU_COUNT_FWR2_R+MU_COUNT_FWR3_S+MU_COUNT_FWR3_R+MU_COUNT_FWR4_S+MU_COUNT_FWR4_R)
parent_db_baseline@db<-filter(parent_db_baseline@db,MU_COUNT<=10)
parent_db_baseline@db$SAME<-"same"
parent_db_group_baseline<-groupBaseline_L(baseline_L = parent_db_baseline, groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
parent_db_baseline2<-calcBaseline_L(db=all_clones_merged_df,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "CDR_FWR")
gc()
parent_db_baseline2@db<-mutate(parent_db_baseline2@db,MU_COUNT=MU_COUNT_CDR_R+MU_COUNT_CDR_S+MU_COUNT_FWR_R+MU_COUNT_FWR_S)
parent_db_baseline2@db<-filter(parent_db_baseline2@db,MU_COUNT<=10)
parent_db_baseline2@db$SAME<-"same"
parent_db_group_baseline2<-groupBaseline_L(baseline_L = parent_db_baseline2, groupBy = "SAME")


#Ploting Error Bar Charts for above none-singletone:
collaped_stats_reg_ALL<-collapsed_db_group_baseline@stats
collaped_stats_reg_ALL$BASELINE_METHOD<-"Consensus"

collaped_stats_reg_CDR_FWR<-collapsed_db_group_baseline2@stats
collaped_stats_reg_CDR_FWR$BASELINE_METHOD<-"Consensus"

parent_stats_reg_ALL<-parent_db_group_baseline@stats
parent_stats_reg_ALL$BASELINE_METHOD<-"Parent"

parent_stats_reg_CDR_FWR<-parent_db_group_baseline2@stats
parent_stats_reg_CDR_FWR$BASELINE_METHOD<-"Parent"

stats_reg_ALL<-rbind(collaped_stats_reg_ALL,parent_stats_reg_ALL)
stats_reg_CDR_FWR<-rbind(collaped_stats_reg_CDR_FWR,parent_stats_reg_CDR_FWR)

base_theme <- theme_bw() + theme(panel.background = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
                                 panel.border = element_rect(color = "black", size = 0.5)) + 
              theme(strip.background = element_rect(fill = "white",color = "black", size = 0.5)) + theme(axis.title.x = element_blank(),
                                                                                                         axis.text.x = element_blank(),
                                                                                                         axis.ticks.x = element_blank()) + 
              theme(legend.position = "top") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

g_eb_ALL<-ggplot(stats_reg_ALL, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_ALL<-g_eb_ALL+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_ALL<-g_eb_ALL + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_ALL<-g_eb_ALL +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_ALL<-g_eb_ALL+base_theme
g_eb_ALL<-g_eb_ALL+ggtitle('Baseline results for methods "Consensus" and "Parent"\n  region type "ALL", data HCV CI10 \n clones with up to 10 mutations,  "local" test')
g_eb_ALL<-g_eb_ALL +ylab(expression(Sigma))
g_eb_ALL

g_eb_CDR_FWR<-ggplot(stats_reg_CDR_FWR, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_CDR_FWR<-g_eb_CDR_FWR+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_CDR_FWR<-g_eb_CDR_FWR + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_CDR_FWR<-g_eb_CDR_FWR +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_CDR_FWR<-g_eb_CDR_FWR+base_theme
g_eb_CDR_FWR<-g_eb_CDR_FWR+ggtitle('Baseline results for methods "Consensus" and "Parent"\n  region type "CDR_FWR", data HCV CI10 \n clones with up to 10 mutations, "local" test')
g_eb_CDR_FWR<-g_eb_CDR_FWR +ylab(expression(Sigma)) 
g_eb_CDR_FWR
```
###Sanity checks:  
### Sanity check 1:    
This step is to be used as a sanity check (to check calcBaseline_L and groupBaseline_L functions):  
Comparing results using region definition of IMGT_V_BY_REGIONS (including CDR1/2 FWR1/2/3) to results using region definition of type "ALL" (including the whole sequence - CDR1/2/3 and FWR1/2/3/4).  
The PDFs of CDR1/2 and FWR1/2/3 look similar (see bellow plots), but they are not identical. 
When looking deeper - the conclusion is that they cannot be identical, since the expected mutation in IMGT_V_BY_REGIONS is calculated based on sequence length of 312, while a region definition of type "ALL" is longer than that. So the relative expected mutations for example of FWR1 in "ALL" region will be smaller than the expected mutations for FWR1 in the IMGT_V_BY_REGIONS.  
But - I did calculate the following:  
exp_cdr1/(exp_cdr1+exp_cdr2+exp_fwr1+exp_fwr2+exp_fwr3)  in region "ALL" is the same as exp_cdr1 in region IMGT_V_BY_REGIONS. 
And same for cdr2, fwr1/2/3.
``` {r sanity_check1}

collapsed_db_IMGT_V<-collapseClones(db=all_clones_merged_df, 
                               sequenceColumn = "SEQUENCE", regionDefinition =IMGT_V_BY_REGIONS,
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline_IMGT_V<-calcBaseline(db=collapsed_db_IMGT_V,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = IMGT_V_BY_REGIONS)
gc()
collapsed_db_baseline_IMGT_V@db$SAME<-"same"
collapsed_db_group_baseline_IMGT_V<-groupBaseline(baseline=collapsed_db_baseline_IMGT_V,groupBy = "SAME")

gc()
parent_db_baseline_IMGT_V<-calcBaseline(db=all_clones_merged_df,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = IMGT_V_BY_REGIONS)
parent_db_baseline_IMGT_V@db$SAME<-"same"
parent_db_group_baseline_IMGT_V<-groupBaseline(baseline = parent_db_baseline_IMGT_V, groupBy = "SAME")


g13<-plotBaselineDensity(collapsed_db_group_baseline_IMGT_V,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF consensus with region IMGT_V_BY_REGIONS")
g13<-g13+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))
g23<-plotBaselineDensity(parent_db_group_baseline_IMGT_V,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF parents with region IMGT_V_BY_REGIONS")
g23<-g23+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))
ggarrange(g11,g13 ,g21 ,g23, ncol = 2, nrow = 2)
```
### Sanity check 2:    
Compare only singletons (expected to get same PDFs in parent vs consensus methods)
1. PDFs using consensus clones.  
2. PDFs using parents sequences. 
Results are that PDFs are the same.  
Also - comparing different objects from 1 and 2 above - are equal.  
```{r sanity_check2}
#1.  Calculating "consensus" sequence through "collapasClones" on all clones, and drawing PDF: 
#    (Note: cannot use all possible :methods" due to some NA in db)
collapsed_db_oneread<-collapseClones_L(db=oneread_clones_db_new, 
                               sequenceColumn = "SEQUENCE", reg_type="ALL",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline_oneread<-calcBaseline_L(db=collapsed_db_oneread,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "ALL")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline_oneread@db$SAME<-"same"
collapsed_db_group_baseline_oneread<-groupBaseline_L(baseline_L=collapsed_db_baseline_oneread,groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
collapsed_db2_oneread<-collapseClones_L(db=oneread_clones_db_new, 
                               sequenceColumn = "SEQUENCE", reg_type="CDR_FWR",
                               germlineColumn = "GERMLINE_IMGT",method="mostMutated")
collapsed_db_baseline2_oneread<-calcBaseline_L(db=collapsed_db2_oneread,sequenceColumn = "CLONAL_SEQUENCE",
                                 germlineColumn = "CLONAL_GERMLINE",regionDefinition = "CDR_FWR")
# adding a column with same value - for the groupBaseline pdf below:
gc()
collapsed_db_baseline2_oneread@db$SAME<-"same"
collapsed_db_group_baseline2_oneread<-groupBaseline_L(baseline_L=collapsed_db_baseline2_oneread,groupBy = "SAME")


#2. Calculating baseline for all reads - when ref sequence is the parent sequence, and not the germline sequence.
#expanding memory alocation:
gc()
parent_db_baseline_oneread<-calcBaseline_L(db=oneread_clones_db_new,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "ALL")
parent_db_baseline_oneread@db$SAME<-"same"
parent_db_group_baseline_oneread<-groupBaseline_L(baseline_L = parent_db_baseline_oneread, groupBy = "SAME")

#Doing the same for "CDR_FWR" regionDefinition:
parent_db_baseline2_oneread<-calcBaseline_L(db=oneread_clones_db_new,
                                    sequenceColumn = "SEQUENCE",
                                    germlineColumn = "PARENT_SEQUENCE",regionDefinition = "CDR_FWR")
gc()
parent_db_baseline2_oneread@db$SAME<-"same"
parent_db_group_baseline2_oneread<-groupBaseline_L(baseline_L = parent_db_baseline2_oneread, groupBy = "SAME")

#3. plottting all PDFs:
g1_11<-plotBaselineDensity(collapsed_db_group_baseline_oneread,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF consensus region ALL\n size 1 clones")
g1_11<-g1_11+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g1_12<-plotBaselineDensity(collapsed_db_group_baseline2_oneread,idColumn = "SAME",sigmaLimits = c(-0.2,0.1),
                    title="PDF consensus region CDR_FWR\n size 1 clones")
g1_12<-g1_12+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g1_21<-plotBaselineDensity(parent_db_group_baseline_oneread,idColumn = "SAME",sigmaLimits = c(-1,0.2),
                    title="PDF parents region ALL\n size 1 clones")
g1_21<-g1_21+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))

g1_22<-plotBaselineDensity(parent_db_group_baseline2_oneread,idColumn = "SAME",sigmaLimits = c(-0.2,0.1),
                    title="PDF parents region CDR_FWR\n size 1 clones")
g1_22<-g1_22+geom_vline(xintercept = 0,col="blue")+theme(legend.position = "none",
                                                     strip.text.y = element_text(size = 8, color = "darkgreen",
                                                                                 angle=0))
ggarrange(g1_11,g1_12 ,g1_21 ,g1_22, ncol = 2, nrow = 2)
```

```{r}
#Ploting Error Bar Charts:
collaped_stats_reg_ALL<-collapsed_db_group_baseline@stats
collaped_stats_reg_ALL$BASELINE_METHOD<-"Consensus"

collaped_stats_reg_CDR_FWR<-collapsed_db_group_baseline2@stats
collaped_stats_reg_CDR_FWR$BASELINE_METHOD<-"Consensus"

parent_stats_reg_ALL<-parent_db_group_baseline@stats
parent_stats_reg_ALL$BASELINE_METHOD<-"Parent"

parent_stats_reg_CDR_FWR<-parent_db_group_baseline2@stats
parent_stats_reg_CDR_FWR$BASELINE_METHOD<-"Parent"

stats_reg_ALL<-rbind(collaped_stats_reg_ALL,parent_stats_reg_ALL)
stats_reg_CDR_FWR<-rbind(collaped_stats_reg_CDR_FWR,parent_stats_reg_CDR_FWR)



base_theme <- theme_bw() + theme(panel.background = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
                                 panel.border = element_rect(color = "black", size = 0.5)) + 
              theme(strip.background = element_rect(fill = "white",color = "black", size = 0.5)) + theme(axis.title.x = element_blank(),
                                                                                                         axis.text.x = element_blank(),
                                                                                                         axis.ticks.x = element_blank()) + 
              theme(legend.position = "top") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

g_eb_ALL<-ggplot(stats_reg_ALL, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_ALL<-g_eb_ALL+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_ALL<-g_eb_ALL + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_ALL<-g_eb_ALL +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_ALL<-g_eb_ALL+base_theme
g_eb_ALL<-g_eb_ALL+ggtitle('Baseline results for methods "Consensus" and "Parent"\n         region type "ALL", data HCV CI10,  "local" test')
g_eb_ALL<-g_eb_ALL +ylab(expression(Sigma))
g_eb_ALL

g_eb_CDR_FWR<-ggplot(stats_reg_CDR_FWR, aes_string(x = "REGION", y = "BASELINE_SIGMA",ymax = max("BASELINE_SIGMA")))
g_eb_CDR_FWR<-g_eb_CDR_FWR+ geom_errorbar(mapping=aes(x=REGION, ymin=BASELINE_CI_LOWER, ymax=BASELINE_CI_UPPER,color=BASELINE_METHOD), position = position_dodge(0.5),width=0.2, size=1) 
g_eb_CDR_FWR<-g_eb_CDR_FWR + geom_hline(yintercept = 0, size = 0.5, linetype = 2, color = "black") 
g_eb_CDR_FWR<-g_eb_CDR_FWR +geom_point(size=4,aes(color=BASELINE_METHOD),position = position_dodge(0.5))
g_eb_CDR_FWR<-g_eb_CDR_FWR+base_theme
g_eb_CDR_FWR<-g_eb_CDR_FWR+ggtitle('Baseline results for methods "Consensus" and "Parent"\n  region type "CDR_FWR", data HCV SC10, "local" test')
g_eb_CDR_FWR<-g_eb_CDR_FWR +ylab(expression(Sigma)) 
g_eb_CDR_FWR



```
