---
title: "Mutations and Lineage trees - miniproj"
author: "Milca Tarshish"
date: "9/1/2019"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Loading libraries:
```{r, message=F}
library(alakazam)
library(igraph)
library(shazam)
library(crayon)
library(dplyr)
rm(list=ls())
```

## Processing data: 

### Adding GERMLINE_IMGT_D_MASK, GERMLINE_IMGT and CLONE columns to database
In case the change-o database does not have columns "GERMLINE_IMGT_D_MASK", "GERMLINE_IMGT" and "CLONE", then this can be calculated by running following python script:  

C:\\Bar_Ilan_3\\projects\\mutations_and_lineage_trees_miniproj\\createGermlines_and_DefineClones.py

Note that that in case the original databse includes colunmes named N1_LENGTH and N2_LENGTH (instead of NP1_LENGTH and NP2_LENGTH) - then they must be renamed to NP1_LENGTH and NP2_LENGTH accordingly.


### Functions to be used in main flow:    

#### Function make_clones_freq_df:
Reads db, and return a list of clone numbers and their fequency:  
```{r func_makes_clones_freq_df}
make_clones_freq_df<-function(data,clone_col="CLONE") {
  clones_freq<-as.data.frame(ftable(data[,c(clone_col)]))
  names(clones_freq)<-c("CLONE","CLONE_FREQ")
  return(clones_freq)
}
```

#### Function make_clones_list:  
This function gets a db as input and generates a list of clones to run on  
The list will include each clone number only once.  
```{r func_make_clones_list}
make_clones_list<- function(db, clone_col="CLONE") {
  clones_list<-unique(db[,c(clone_col)])
  return(clones_list)
}
```


#### Function make_chaneoClone_cur_clone:  
Creating a changeoclone object for one specific clone:  
```{r func_make_chaneoClone_cur_clone}
make_chaneoClone_cur_clone <- function(db,cur_clone_num,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  cur_clone_db<-subset(db,CLONE==cur_clone_num)
  cur_clone_obj<-makeChangeoClone(data=cur_clone_db,id=id,seq=seq,germ=germ,vcall=vcall,jcall=jcall,
                                       junc_len=junc_len,clone=clone,mask_char=mask_char,
                                       max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj@data$V_CALL<-cur_clone_obj@v_gene
  cur_clone_obj@data$J_CALL<-cur_clone_obj@j_gene
  cur_clone_obj@data$CLONE<-cur_clone_obj@clone
  cur_clone_obj@data$GERMLINE_IMGT<-cur_clone_obj@germline
  cur_clone_obj@data$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  # marking the cur_clone_obj data size:
  # If only one line, it means that even though the original clone size was of more than 1 line 
  # - then all the lines were the same, and they all collapsed to one line while building a clone object.
  # special handling will be needed here.
  cur_clone_size<-dim(cur_clone_obj@data)[1]
  setClass("make_chaneoClone_cur_clone_class", slots=list(ChangeoClone_obj="ChangeoClone", size="numeric"))
  ret_class<-new("make_chaneoClone_cur_clone_class",ChangeoClone_obj=cur_clone_obj,size=cur_clone_size)
  return(ret_class)
}
```

#### function make_graph_cur_clone: 
Making a graph out of ChangeoClone object:  
```{r func_make_graph_cur_clone}
make_graph_cur_clone<-function(cur_clone_obj,dnapars_exec) {
  # The below line is in order to avoid warning message
  # (message: "binding factor and character vector, coercing into character vector")
  cur_clone_obj@data$SEQUENCE_ID<-as.character(cur_clone_obj@data$SEQUENCE_ID) 
  cur_clone_graph<-buildPhylipLineage(cur_clone_obj,dnapars_exec,rm_temp = TRUE)  
  # in case that the cur_clone_num does not include at least 2 unique sequences - the cur_clone_graph will be "NULL".
  #note: "N" instead of A/C/G/T does not make a sequence unique.
  return(cur_clone_graph)
}
```

#### function make_graph_df:  
Generating a data frame from graph object, and mering it with clone database (only for objects with more than one line):  
```{r func_make_graph_df}
make_graph_df <- function(cur_clone_graph,cur_clone_obj) {
  # extracting the cur_clone_num from the inputs to function:
  cur_clone_num<-cur_clone_obj@clone
  # generating a data frame from the clone igraph object (- for getting the inferred sequences from the graph,
  # and the parent information):
  cur_clone_graph_df<-summarizeSubtrees(cur_clone_graph,fields="sequence")
  # merging the db from clone object and from graph:
  cur_clone_merged_df<-merge(x=cur_clone_obj@data,y=cur_clone_graph_df,by.x="SEQUENCE_ID",by.y="NAME",all=T)
  # Renaming SEQUENCE_ID column to ORIG_SEQUENCE_ID, and renaming PARENT to ORIG_PARENT:
  cur_clone_merged_df$ORIG_SEQUENCE_ID<-cur_clone_merged_df$SEQUENCE_ID
  cur_clone_merged_df$ORIG_PARENT<-cur_clone_merged_df$PARENT
 
  # uniquifying some values in merged data frame, and filling some missing values:
  
  #1. Replacing inferred sequences names with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices
  cur_clone_merged_df$PARENT<-gsub(pattern="Inferred",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Inferred",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Inferred",x=V(cur_clone_graph)$label,
                                 replacement=paste("Inferred_",cur_clone_num,"_",sep=""))
  
  #2. Replacing Germline sequence name with a unique name (using the clone number). 
  # Doing so for both SEQUENCE_ID and PARENT and graph vertices:
  cur_clone_merged_df$PARENT<-gsub(pattern="Germline",x=cur_clone_merged_df$PARENT,
                                   replacement=paste("Germline_",cur_clone_num,sep=""))
  cur_clone_merged_df$SEQUENCE_ID<-gsub(pattern="Germline",x=cur_clone_merged_df$SEQUENCE_ID,
                                        replacement=paste("Germline_",cur_clone_num,sep=""))
  V(cur_clone_graph)$label<-gsub(pattern="Germline",x=V(cur_clone_graph)$label,
                                 replacement= paste("Germline_",cur_clone_num,sep=""))
  
  #3. Now need to fill in missing values for germline sequence and inffered sequences:
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$J_CALL<-cur_clone_obj@j_gene
  cur_clone_merged_df$CLONE<-cur_clone_num
  cur_clone_merged_df$V_CALL<-cur_clone_obj@v_gene
  cur_clone_merged_df$JUNCTION_LENGTH<-cur_clone_obj@junc_len
  cur_clone_merged_df$GERMLINE_IMGT<-cur_clone_obj@germline
  
  #4. setting a new SEQUENCE_ID column with following format:  
  #<CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.   
  cur_clone_merged_df$SEQUENCE_ID <-  
                              paste(cur_clone_num,"_",c(1:length(cur_clone_merged_df$ORIG_SEQUENCE_ID)),sep="")
  cur_clone_merged_df<-mutate(cur_clone_merged_df,
                              SEQUENCE_ID=ifelse(grepl("Germline|Inferred",ORIG_SEQUENCE_ID),
                                                 paste(cur_clone_num,"_",ORIG_SEQUENCE_ID,sep=""),SEQUENCE_ID))

  #5. Doing the same for PARENT column: 
  # setting a new PARENT column with following format:  
  # <CLONE_NUM>_<SEQUENCE_SERIAL_NUM>  
  #Except for Germline and Inferred names which will remain as is.
  cur_clone_merged_df$PARENT<-cur_clone_merged_df[match(cur_clone_merged_df$ORIG_PARENT,                                                                    cur_clone_merged_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]
 
  #6. Removing the SEQUENCE column, as it does not include sequences of germline and inferred.
  #Renaming the "sequence" column to "SEQUENCE"
  cur_clone_merged_df<-subset(cur_clone_merged_df,select=c(-SEQUENCE))
  cur_clone_merged_df<-rename(cur_clone_merged_df,SEQUENCE=sequence)

  #7. Adding the parent sequence as a new column:
  cur_clone_merged_df$PARENT_SEQUENCE<-cur_clone_merged_df[match(cur_clone_merged_df$PARENT,
                                                                 cur_clone_merged_df$SEQUENCE_ID),"SEQUENCE"]         
  # filling the parent sequece of the Germline sequence to be its own sequence (=GERMLINE_IMGT):
  cur_clone_merged_df<-mutate(cur_clone_merged_df,PARENT_SEQUENCE=ifelse(is.na(PARENT_SEQUENCE),
                                                                         GERMLINE_IMGT,PARENT_SEQUENCE))
  return(cur_clone_merged_df)
}
```

#### function draw_clone_lineage_tree:  
For viewing a tree plot of a specific clone:  
Note that this function will give an error in case that all the sequences in the db of the specific clone  
are the same (as no lineage tree can be built on that).
```{r func_draw_clone_lineage_tree, fig.width = 15, fig.height=10}
draw_clone_lineage_tree<-function(db,cur_clone=NULL,id="SEQUENCE_ID",seq="SEQUENCE_IMGT",
                                       germ="GERMLINE_IMGT",vcall="V_CALL",jcall="J_CALL",
                                       junc_len="JUNCTION_LENGTH",clone="CLONE",mask_char="N",
                                       max_mask=0,pad_end=FALSE) {
  dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
  ret_class<-make_chaneoClone_cur_clone(db=db,cur_clone_num=cur_clone,id=id,seq=seq,germ=germ,                                                         vcall=vcall,jcall=jcall,junc_len=junc_len, 
                                        clone=clone,mask_char=mask_char,
                                        max_mask=max_mask,pad_end=pad_end)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  V(cur_clone_graph)$color <- ifelse(grepl("Germline",V(cur_clone_graph)$label),"lightgreen",
                              ifelse(grepl("Inferred",V(cur_clone_graph)$label),"lightpink","lightblue"))
  #making the graph vertices show the simple SEQUENCE_ID
  cur_clone_only_df<-filter(all_clones_merged_df,CLONE==cur_clone)
  #V(cur_clone_graph)$seq_num<-cur_clone_only_df[match(V(cur_clone_graph)$label,
  #                                                    cur_clone_only_df$ORIG_SEQUENCE_ID),"SEQUENCE_ID"]   
  E(cur_clone_graph)$label <- ""
  par(mar=c(0, 0, 0, 0) + 1)
  plot(cur_clone_graph, layout=layout_as_tree, edge.arrow.mode=0, 
       vertex.frame.color="black", vertex.label.cex=0.8,
       vertex.label.color="black", vertex.size=18, vertex.label=V(cur_clone_graph)$seq_num, 
       main=paste("Lineage tree for clone ",cur_clone))
  legend("topright", c("Germline", "Inferred", "Sample"), 
       fill=c("lightgreen", "lightpink", "lightblue"), cex=0.75)
}
```

#### function make_region:  
Getting as input a JUNCTION_LENGTH, SEQUENCE_IMGT, reg_type.  
and outputing a RegionDefinition object that includes following regions:   
If reg_type="ALL", the regions will be as follows:  
- FWR1: Bases	1 to 78     (based on IMGT_V_BY_REGIONS definitions)  
- CDR1: Bases	79 to 114   (based on IMGT_V_BY_REGIONS definitions) 
- FWR2: Bases	115 to 165  (based on IMGT_V_BY_REGIONS definitions)  
- CDR2: Bases	166 to 195  (based on IMGT_V_BY_REGIONS definitions)  
- FWR3: Bases	196 to 312  (based on IMGT_V_BY_REGIONS definitions)
- CDR3: Bases	313 to (313+JUNCTION_LENGTH-6) - since junction sequnece includes (on the left) the last codon from FWR3, and (on the right) the first codon from FWR4.  
- FWR4: Bases	(313+JUNCTION_LENGTH-6+1) to SEQUENCE_LENGTH.  
If reg_type="CDR_FWR", the regions will be same as above, except that all FWR1/2/3/4 will be named "FWR",  
and all CDR1/2/3 will be named "CDR"
```{r func_make_region}
make_region <- function(JUNCTION_LENGTH,SEQUENCE_IMGT,reg_type="ALL") {
  # First need to extract sequence length from sequence:
  SEQ_LEN<-nchar(SEQUENCE_IMGT)
  name<-"IMGT_FULL_BY_REGIONS"
  description<-"IMGT numbering scheme defining the V(D)J segment by individual CDR and FWR regions, including CDR3 and FWR4"
  boundaries<-factor(IMGT_V_BY_REGIONS@boundaries  ,levels=c(levels(IMGT_V_BY_REGIONS@boundaries),"CDR3","FWR4"))
  boundaries[313:(313+as.integer(JUNCTION_LENGTH)-6-1)]<-factor("CDR3")
  boundaries[(313+as.integer(JUNCTION_LENGTH)-6):SEQ_LEN]<-factor("FWR4")
  seqLength<-SEQ_LEN
  regions<-c("CDR1","CDR2","CDR3","FWR1","FWR2","FWR3","FWR4")
  labels<-c("CDR1_R","CDR1_S","CDR2_R","CDR2_S","CDR3_R","CDR3_S","FWR1_R","FWR1_S","FWR2_R","FWR2_S","FWR3_R","FWR3_S","FWR4_R","FWR4_S")
  if(reg_type=="CDR_FWR") {
    name<-"IMGT_FULL_BY_CDR_FWR"
    description<-"IMGT numbering scheme defining the V(D)J segment only by CDR/FWR regions, including CDR3 and FWR4"
    boundaries<-gsub(pattern="FWR.",replacement = "FWR", x=boundaries,perl=TRUE)
    boundaries<-gsub(pattern="CDR.",replacement = "CDR", x=boundaries,perl=TRUE)
    boundaries<-factor(boundaries,levels=c("FWR","CDR"))
    regions<-c("CDR","FWR")
    labels<-c("CDR_R","CDR_S","FWR_R","FWR_S")
  }
  citation<-"http://www.imgt.org/IMGTScientificChart/Nomenclature/IMGT-FRCDRdefinition.html"
  ret_class<-new("RegionDefinition",name=name,description=description,boundaries=boundaries,
                                    seqLength=seqLength,regions=regions,labels=labels,
                                    citation=citation)
  return(ret_class)
}
```

#### function get_clone_region:  
This function gets as input a clone number and a data frame with sequences and their clone number,  
And returns the RegionDefinition object of type IMGT_FULL_BY_REGIONS for this specific clone.  
The function gets as input also the column name of the clone and sequence in the data frame.
Note that the region definition is same for all sequences in clone - so doing it based on first sequence in clone.  
```{r func_get_clone_region}
get_clone_region <- function(db,clone_num,seq_col="SEQUENCE",junc_len_col="JUNCTION_LENGTH",
                             clone_col="CLONE",reg_type="ALL") {
  # getting one of the sequences of the specific clone: 
  # clone_col1<-as.symbol(clone_col)
  clone_db<-filter(db,(!!as.name(clone_col))==clone_num)
  #clone_db<-filter(db,CLONE==clone_num)
  seq<-clone_db[1,seq_col]
  junc_len<-clone_db[1,junc_len_col]
  reg<-make_region(JUNCTION_LENGTH = junc_len, SEQUENCE_IMGT = seq, reg_type=reg_type)
  return(reg)
}
```


#### function observedMutations_L:  
Very similar to observedMutations function, except that it runs with regard to parent sequence in lineage tree,  
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_observedMutations_L}
observedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", refColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE", reg_type="ALL", mutationDefinition = NULL, 
                                ambiguousMode = c("eitherOr", "and"), 
                                frequency = FALSE, combine = FALSE, nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function observedMutations with its own regionDefinition.
  # For all clones - the refColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"],
                               reg_type=reg_type)
    clone_observeedMutations_db<-observedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn=refColumn,
                                                   regionDefinition=cur_clone_reg,                                              
                                                   mutationDefinition=mutationDefinition,
                                                   ambiguousMode=ambiguousMode,
                                                   frequency=frequency,combine=combine,nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      observeedMutations_db<-clone_observeedMutations_db
      first_clone<-0
    }
    else {
      observeedMutations_db<-rbind(observeedMutations_db,clone_observeedMutations_db)
    }
  } # end of for loop
  return(observeedMutations_db)
} # end of function
```

#### function expectedMutations_L:  
Very similar to expectedMutations function, except that it runs with regard to parent sequence in lineage tree,
Instead of with regard to GERMLINE_IMGT sequence. so on each sequence in the clone - the observed number of   
mutations is computed with regard to its parent sequence (and not with regard to the germline sequence).  
Note: The regionDefinition - is different for each clone.
```{r func_expectedMutations_L}
expectedMutations_L <- function(db,sequenceColumn = "SEQUENCE_IMGT", refColumn = "PARENT_SEQUENCE",
                                clone_col="CLONE",reg_type="ALL", targetingModel = HH_S5F,
                                mutationDefinition = NULL, nproc = 1) {
  # Since each clone needs a different regionDefinition - then this function will loop on all clones in db,
  # and for each clone will run the function expectedMutations with its own regionDefinition.
  # For all clones - the refColumn will point to the parent sequence column.
  # before looping: setting a list of all clones in db:  
  clones_in_db<-unique(db[,c(clone_col)])
  first_clone<-1
  for (cur_clone in clones_in_db) {
    # filtering out of db - only lines for cur_clone:
    cur_clone_db<-filter(db,(!!as.name(clone_col))==cur_clone)
    # setting the regionDefinition for the specific clone:
    cur_clone_reg<-make_region(JUNCTION_LENGTH = cur_clone_db[1,"JUNCTION_LENGTH"],
                               SEQUENCE_IMGT =   cur_clone_db[1,"SEQUENCE"],
                               reg_type=reg_type)
    clone_expectedMutations_db<-expectedMutations(db=cur_clone_db,sequenceColumn = sequenceColumn,
                                                   germlineColumn =refColumn,
                                                   targetingModel=targetingModel,
                                                   regionDefinition=cur_clone_reg,
                                                   mutationDefinition=mutationDefinition,
                                                   nproc=nproc) 
    # binding current clone_observeedMutations_db to one big data frame:
    if (first_clone==1) {
      expectedMutations_db<-clone_expectedMutations_db
      first_clone<-0
    }
    else {
      expectedMutations_db<-rbind(expectedMutations_db,clone_expectedMutations_db)
    }
  } # end of for loop
  return(expectedMutations_db)
} # end of function
```


### Main program: Using all functions above on database:  
```{r main_program}
# 1. Loading data from HCV_B database:  
file_pointer<-"C:\\Bar Ilan 3 data - not backed up\\HCV_B\\CI10_rename_p1_p2_germ-pass_clone-pass_germ-pass.tab"
clones_db<-read.csv(file_pointer, header=TRUE,sep='\t')
dim(clones_db)

# 2. Removing from db sequences that their IMGT sequence is shorter than 312 nucleotides.
#    The reason for this is that running Expected mutations on them does not run properly, as they are missing full
#    range of FWR1/CDR1/FWR2/CDR2/FWR3 which is 312 nucleotides (not sure at all why they even exist in the db). 
clones_db<-subset(clones_db,nchar(as.character(SEQUENCE_IMGT))>=312)

# 3. create a list of clones to loop on:  
clones_to_build_trees<-make_clones_list(clones_db)
#clones_to_build_trees<-c(4070,12,259,11)

# 4. Loop on all clones in db above:
first_clone<-TRUE
first_size_1_clone<-TRUE
#loop_start_time<-Sys.time()
dnapars_exec<-"c:\\Users\\milcat\\phylip-3.698\\exe\\dnapars.exe"
size_1_clones<-NULL
for (clone_index in clones_to_build_trees) {
  ret_class<-make_chaneoClone_cur_clone(db = clones_db,cur_clone_num = clone_index)
  cur_clone_obj<-ret_class@ChangeoClone_obj
  cur_clone_size<-ret_class@size
  # in case  the clone size is of 1 row - keep them in separate db and  skip to next clone, as they will need special care later:
  # This also suppresses following warning:
  # "Warning in buildPhylipLineage(cur_clone_obj, dnapars_exec, rm_temp = TRUE): 
  if(cur_clone_size==1) {
    size_1_clones<-c(size_1_clones,clone_index)
    if(first_size_1_clone){
      size_1_clone_db<-cur_clone_obj@data
      first_size_1_clone<-FALSE
    }
    else {
      size_1_clone_db<-rbind(size_1_clone_db,cur_clone_obj@data)
    }
    next
  }
  cur_clone_graph<-make_graph_cur_clone(cur_clone_obj,dnapars_exec)
  if (!is.null(cur_clone_graph)) { 
    cur_clone_merged_df<-make_graph_df(cur_clone_graph,cur_clone_obj)
    if(first_clone) {
      first_clone<-FALSE
      all_clones_merged_df<-cur_clone_merged_df
    } #endif first_clone
    else {
      all_clones_merged_df<-rbind(all_clones_merged_df,cur_clone_merged_df)
    }
  } # endif
} # endfor

# 5. Taking care of clones of size 1:
#    preparing a db with columns same as final db (all_clones_merged_df) - that includes the clones of size 1:
#     They can originate from 2 reasons:
#        a. clones that in original db had one read only.
#        b. clones that had more than one read, but after running makeChangeoClone - all read collapsed all to one line.
#    These clones of size 1 will be added later to final db.
oneread_clones_db_new<-setNames(data.frame(matrix(ncol = length(names(all_clones_merged_df)), nrow = length(size_1_clones))), 
                                names(all_clones_merged_df))
oneread_clones_db_new[,"CLONE"]                  <-size_1_clone_db[,"CLONE"]
oneread_clones_db_new[,"V_CALL"]                 <-size_1_clone_db[,"V_CALL"]
oneread_clones_db_new[,"J_CALL"]                 <-size_1_clone_db[,"J_CALL"]
oneread_clones_db_new[,"GERMLINE_IMGT"]          <-size_1_clone_db[,"GERMLINE_IMGT"]
oneread_clones_db_new[,"JUNCTION_LENGTH"]        <-size_1_clone_db[,"JUNCTION_LENGTH"]
oneread_clones_db_new[,"SEQUENCE"]               <-size_1_clone_db[,"SEQUENCE"]
oneread_clones_db_new[,"ORIG_SEQUENCE_ID"]       <-size_1_clone_db[,"SEQUENCE_ID"]
oneread_clones_db_new[,"PARENT_SEQUENCE"]        <-size_1_clone_db[,"GERMLINE_IMGT"]
oneread_clones_db_new[,"PARENT"]                 <-paste(size_1_clone_db[,"CLONE"],"_Germline",sep="")
oneread_clones_db_new[,"SEQUENCE_ID"]            <-paste(size_1_clone_db[,"CLONE"],"_1",sep="")

# 6. adding for each one read clone - a new line of its germline:
oneread_clones_db_germ<-oneread_clones_db_new
oneread_clones_db_germ$SEQUENCE_ID<-oneread_clones_db_new$PARENT
oneread_clones_db_germ$SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT
oneread_clones_db_germ$PARENT<-"NA"
oneread_clones_db_germ$ORIG_PARENT<-"Germline"
oneread_clones_db_germ$PARENT_SEQUENCE<-oneread_clones_db_new$GERMLINE_IMGT
oneread_clones_db_new<-rbind(oneread_clones_db_new,oneread_clones_db_germ)
oneread_clones_db_new$SEQUENCE<-as.character(oneread_clones_db_new$SEQUENCE)
oneread_clones_db_new$V_CALL<-as.character(oneread_clones_db_new$V_CALL)
oneread_clones_db_new$J_CALL<-as.character(oneread_clones_db_new$J_CALL)
oneread_clones_db_new$CLONE<-as.character(oneread_clones_db_new$CLONE)

# 7. adding the one read clone db to the main db:
all_clones_merged_df<-rbind(all_clones_merged_df,oneread_clones_db_new)

# 8. adding to db - the expected and obsereved mutation columns - for all regions.
all_clones_merged_df_ALL_regions<-observedMutations_L(all_clones_merged_df,
                                                      sequenceColumn = "SEQUENCE",
                                                      reg_type="ALL")
all_clones_merged_df_ALL_regions<-expectedMutations_L(all_clones_merged_df_ALL_regions,
                                                      sequenceColumn = "SEQUENCE",
                                                      reg_type="ALL")
all_clones_merged_df_CDRFWR_regions<-observedMutations_L(all_clones_merged_df,
                                                         sequenceColumn = "SEQUENCE",
                                                         reg_type = "CDR_FWR")
all_clones_merged_df_CDRFWR_regions<-expectedMutations_L(all_clones_merged_df_CDRFWR_regions,
                                                         sequenceColumn = "SEQUENCE",
                                                         reg_type = "CDR_FWR")

#write.csv(all_clones_merged_df,file="C:\\Bar_Ilan_3\\projects\\all_clones_merged_df.csv")

```


